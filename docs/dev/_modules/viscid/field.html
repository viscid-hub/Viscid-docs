
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>viscid.field &#8212; Viscid 1.0.0.dev14 documentation</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<link rel="icon" href="../../_static/favicon.ico" type="image/x-icon">
<link rel="shortcut icon" href="../../_static/favicon.ico" type="image/x-icon">
<link rel="apple-touch-icon-precomposed" href="../../_static/Vicon_128.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="apple-mobile-web-app-capable" content="yes">
<link rel="stylesheet" href="../../_static/my-css.css" type="text/css" />

<script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          Viscid</a>
        <span class="navbar-text navbar-version pull-left"><b>1.0.0.dev14</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
    <li class="dropdown">
      <a role="button"
         id="dLabelNavLinxToc"
         data-toggle="dropdown"
         data-target="#"
         href="#">Tutorial <b class="caret"></b></a>
      <ul class="dropdown-menu navlinktoc"
          role="menu">
          <li class="toctree-l1">
            <a class="reference internal", href="../../installation.html">Installation</a>
          </li>
          <li class="toctree-l1">
            <a class="reference internal", href="../../tutorial/load_save.html">Loading & Saving</a>
          </li>
          <li class="toctree-l1">
            <a class="reference internal", href="../../tutorial/creating_fields.html">Creating Fields</a>
          </li>
          <li class="toctree-l1">
            <a class="reference internal", href="../../tutorial/slicing.html">Slicing Fields</a>
          </li>
          <li class="toctree-l1">
            <a class="reference internal", href="../../tutorial/plotting_scalars.html">Plotting Scalars</a>
          </li>
          <li class="toctree-l1">
            <a class="reference internal", href="../../tutorial/plotting_vectors.html">Plotting Vectors</a>
          </li>
          <li class="toctree-l1">
            <a class="reference internal", href="../../tutorial/mayavi.html">3D Plots (Mayavi)</a>
          </li>
          <li class="toctree-l1">
            <a class="reference internal", href="../../tutorial/openggcm.html">OpenGGCM Specific</a>
          </li>
          <li class="toctree-l1">
            <a class="reference internal", href="../../tutorial/ionosphere.html">Ionosphere</a>
          </li>
          <li class="toctree-l1">
            <a class="reference internal", href="../../tutorial/stream_and_interp.html">Streamline and Interpolation</a>
          </li>
          <li class="toctree-l1">
            <a class="reference internal", href="../../tutorial/magnetic_topology.html">Magnetic Topology</a>
          </li>
          <li class="toctree-l1">
            <a class="reference internal", href="../../tutorial/magnetopause.html">Magnetopause</a>
          </li>
          <li class="toctree-l1">
            <a class="reference internal", href="../../tutorial/quasi_potential.html">Quasi Potential</a>
          </li>
      </ul>
    </li>

            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../philosophy.html">Philosophy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../indexing.html">Indexing Fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../functions.html">Useful Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../plot_options.html">Plot Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tips_and_tricks.html">Tips &amp; Tricks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../custom_behavior.html">Custom Behavior (rc file)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mpl_style_gallery.html">Matplotlib Style Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev_guide.html">Developerâ€™s Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/viscid.html">API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../changes.html">ChangeLog</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content" role="main">
      
  <h1>Source code for viscid.field</h1><div class="highlight"><pre>
<span></span><span class="c1"># pylint: disable=too-many-lines</span>
<span class="sd">&quot;&quot;&quot;Fields are the basis of Viscid&#39;s data abstration</span>

<span class="sd">Fields belong in grids, or by themselves as a result of a calculation.</span>
<span class="sd">They can belong to a :class:`Grid` as the result of a file load, or</span>
<span class="sd">by themselves as the result of a calculation. This module has some</span>
<span class="sd">convenience functions for creating fields similar to `Numpy`.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">count</span><span class="p">,</span> <span class="n">islice</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">isclass</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">viscid</span>
<span class="kn">from</span> <span class="nn">viscid</span> <span class="k">import</span> <span class="n">logger</span>
<span class="kn">from</span> <span class="nn">viscid.compat</span> <span class="k">import</span> <span class="n">string_types</span><span class="p">,</span> <span class="n">izip_longest</span>
<span class="kn">from</span> <span class="nn">viscid</span> <span class="k">import</span> <span class="n">coordinate</span>
<span class="kn">from</span> <span class="nn">viscid.cython</span> <span class="k">import</span> <span class="n">interp_trilin</span>
<span class="kn">from</span> <span class="nn">viscid</span> <span class="k">import</span> <span class="n">sliceutil</span>
<span class="kn">from</span> <span class="nn">viscid</span> <span class="k">import</span> <span class="n">tree</span>
<span class="kn">from</span> <span class="nn">viscid.vutil</span> <span class="k">import</span> <span class="n">subclass_spider</span>


<span class="n">LAYOUT_DEFAULT</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span>  <span class="c1"># do not translate</span>
<span class="n">LAYOUT_INTERLACED</span> <span class="o">=</span> <span class="s2">&quot;interlaced&quot;</span>
<span class="n">LAYOUT_FLAT</span> <span class="o">=</span> <span class="s2">&quot;flat&quot;</span>
<span class="n">LAYOUT_SCALAR</span> <span class="o">=</span> <span class="s2">&quot;scalar&quot;</span>
<span class="n">LAYOUT_OTHER</span> <span class="o">=</span> <span class="s2">&quot;other&quot;</span>

<span class="n">_DEFAULT_COMPONENT_NAMES</span> <span class="o">=</span> <span class="s2">&quot;xyzuvw&quot;</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;arrays2field&#39;</span><span class="p">,</span> <span class="s1">&#39;dat2field&#39;</span><span class="p">,</span> <span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="s1">&#39;empty&#39;</span><span class="p">,</span> <span class="s1">&#39;zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;ones&#39;</span><span class="p">,</span>
           <span class="s1">&#39;full_like&#39;</span><span class="p">,</span> <span class="s1">&#39;empty_like&#39;</span><span class="p">,</span> <span class="s1">&#39;zeros_like&#39;</span><span class="p">,</span> <span class="s1">&#39;ones_like&#39;</span><span class="p">,</span>
           <span class="s1">&#39;mfield&#39;</span><span class="p">,</span> <span class="s1">&#39;mfield_cell&#39;</span><span class="p">,</span> <span class="s1">&#39;mfield_node&#39;</span><span class="p">,</span>
           <span class="s1">&#39;scalar_fields_to_vector&#39;</span><span class="p">,</span> <span class="s1">&#39;wrap_field&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="arrays2field"><a class="viewcode-back" href="../../api/viscid.field.html#viscid.arrays2field">[docs]</a><span class="k">def</span> <span class="nf">arrays2field</span><span class="p">(</span><span class="n">crd_arrs</span><span class="p">,</span> <span class="n">dat_arr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;NoName&quot;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">crd_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">crd_names</span><span class="o">=</span><span class="s2">&quot;xyzuvw&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Turn arrays into fields so they can be used in viscid.plot, etc.</span>

<span class="sd">    This is a convenience function that takes care of making coordnates</span>
<span class="sd">    and the like. If the default behavior doesn&#39;t work for you, you&#39;ll</span>
<span class="sd">    need to make your own coordnates and call</span>
<span class="sd">    :py:func:`viscid.field.wrap_field`.</span>

<span class="sd">    Args:</span>
<span class="sd">        crd_arrs (list of ndarrays): xyz list of ndarrays that</span>
<span class="sd">            describe the node centered coordnates of the field</span>
<span class="sd">        dat_arr (ndarray): data with len(crd_arrs) or len(crd_arrs) + 1</span>
<span class="sd">            dimensions</span>
<span class="sd">        name (str): some name</span>
<span class="sd">        center (str, None): If not None, translate field to this</span>
<span class="sd">            centering (node or cell)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">crds</span> <span class="o">=</span> <span class="n">coordinate</span><span class="o">.</span><span class="n">arrays2crds</span><span class="p">(</span><span class="n">crd_arrs</span><span class="p">,</span> <span class="n">crd_type</span><span class="o">=</span><span class="n">crd_type</span><span class="p">,</span> <span class="n">crd_names</span><span class="o">=</span><span class="n">crd_names</span><span class="p">)</span>

    <span class="c1"># discover what kind of data was given</span>
    <span class="n">crds_shape_nc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">crds</span><span class="o">.</span><span class="n">shape_nc</span><span class="p">)</span>
    <span class="n">crds_shape_cc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">crds</span><span class="o">.</span><span class="n">shape_cc</span><span class="p">)</span>
    <span class="n">dat_arr_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dat_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dat_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">crds</span><span class="o">.</span><span class="n">shape_nc</span><span class="p">):</span>
        <span class="n">discovered_type</span> <span class="o">=</span> <span class="s2">&quot;scalar&quot;</span>
        <span class="n">discovered_layout</span> <span class="o">=</span> <span class="n">LAYOUT_FLAT</span>
        <span class="k">if</span> <span class="n">crds_shape_nc</span> <span class="o">==</span> <span class="n">dat_arr_shape</span><span class="p">:</span>
            <span class="n">discovered_center</span> <span class="o">=</span> <span class="s2">&quot;node&quot;</span>
        <span class="k">elif</span> <span class="n">crds_shape_cc</span> <span class="o">==</span> <span class="n">dat_arr_shape</span><span class="p">:</span>
            <span class="n">discovered_center</span> <span class="o">=</span> <span class="s2">&quot;cell&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t detect centering for scalar dat_arr&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">dat_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">crds</span><span class="o">.</span><span class="n">shape_nc</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">discovered_type</span> <span class="o">=</span> <span class="s2">&quot;vector&quot;</span>
        <span class="k">if</span> <span class="n">crds_shape_nc</span> <span class="o">==</span> <span class="n">dat_arr_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">discovered_layout</span> <span class="o">=</span> <span class="n">LAYOUT_INTERLACED</span>
            <span class="n">discovered_center</span> <span class="o">=</span> <span class="s2">&quot;node&quot;</span>
        <span class="k">elif</span> <span class="n">crds_shape_cc</span> <span class="o">==</span> <span class="n">dat_arr_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">discovered_layout</span> <span class="o">=</span> <span class="n">LAYOUT_INTERLACED</span>
            <span class="n">discovered_center</span> <span class="o">=</span> <span class="s2">&quot;cell&quot;</span>
        <span class="k">elif</span> <span class="n">crds_shape_nc</span> <span class="o">==</span> <span class="n">dat_arr_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">discovered_layout</span> <span class="o">=</span> <span class="n">LAYOUT_FLAT</span>
            <span class="n">discovered_center</span> <span class="o">=</span> <span class="s2">&quot;node&quot;</span>
        <span class="k">elif</span> <span class="n">crds_shape_cc</span> <span class="o">==</span> <span class="n">dat_arr_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">discovered_layout</span> <span class="o">=</span> <span class="n">LAYOUT_FLAT</span>
            <span class="n">discovered_center</span> <span class="o">=</span> <span class="s2">&quot;cell&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t detect centering for vector dat_arr&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;crds and data have incompatable dimensions: </span><span class="si">{0}</span><span class="s2"> </span><span class="si">{1}</span><span class="s2">&quot;</span>
                         <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dat_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">crds</span><span class="o">.</span><span class="n">shape_nc</span><span class="p">))</span>

    <span class="n">fld</span> <span class="o">=</span> <span class="n">wrap_field</span><span class="p">(</span><span class="n">dat_arr</span><span class="p">,</span> <span class="n">crds</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">fldtype</span><span class="o">=</span><span class="n">discovered_type</span><span class="p">,</span>
                     <span class="n">center</span><span class="o">=</span><span class="n">discovered_center</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">discovered_layout</span><span class="p">)</span>
    <span class="n">fld</span> <span class="o">=</span> <span class="n">fld</span><span class="o">.</span><span class="n">as_centered</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fld</span></div>

<div class="viewcode-block" id="dat2field"><a class="viewcode-back" href="../../api/viscid.field.html#viscid.dat2field">[docs]</a><span class="k">def</span> <span class="nf">dat2field</span><span class="p">(</span><span class="n">dat_arr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;NoName&quot;</span><span class="p">,</span> <span class="n">fldtype</span><span class="o">=</span><span class="s2">&quot;scalar&quot;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">layout</span><span class="o">=</span><span class="n">LAYOUT_FLAT</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Makes np.arange coordnate arrays and calls arrays2field</span>

<span class="sd">    Args:</span>
<span class="sd">        dat_arr (ndarray): data</span>
<span class="sd">        name (str): name of field</span>
<span class="sd">        fldtype (str, optional): &#39;scalar&#39; / &#39;vector&#39;</span>
<span class="sd">        center (str, None): If not None, translate field to this</span>
<span class="sd">            centering (node or cell)</span>
<span class="sd">        layout (TYPE, optional): Description</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sshape</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">fldtype</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;scalar&quot;</span><span class="p">:</span>
        <span class="n">sshape</span> <span class="o">=</span> <span class="n">dat_arr</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">elif</span> <span class="n">fldtype</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;vector&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">layout</span> <span class="o">==</span> <span class="n">LAYOUT_FLAT</span><span class="p">:</span>
            <span class="n">sshape</span> <span class="o">=</span> <span class="n">dat_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="n">layout</span> <span class="o">==</span> <span class="n">LAYOUT_INTERLACED</span><span class="p">:</span>
            <span class="n">sshape</span> <span class="o">=</span> <span class="n">dat_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown layout: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">layout</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown type: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fldtype</span><span class="p">))</span>

    <span class="n">crd_arrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dat_arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sshape</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">arrays2field</span><span class="p">(</span><span class="n">crd_arrs</span><span class="p">,</span> <span class="n">dat_arr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">)</span></div>

<div class="viewcode-block" id="full"><a class="viewcode-back" href="../../api/viscid.field.html#viscid.full">[docs]</a><span class="k">def</span> <span class="nf">full</span><span class="p">(</span><span class="n">crds</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;f8&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;NoName&quot;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s2">&quot;cell&quot;</span><span class="p">,</span>
         <span class="n">layout</span><span class="o">=</span><span class="n">LAYOUT_FLAT</span><span class="p">,</span> <span class="n">nr_comps</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">crd_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">crd_names</span><span class="o">=</span><span class="s2">&quot;xyzuvw&quot;</span><span class="p">,</span>
         <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Analogous to `numpy.full`</span>

<span class="sd">    Parameters:</span>
<span class="sd">        crds (Coordinates, list, or tuple): Can be a coordinates</span>
<span class="sd">            object. Can also be a list of ndarrays describing</span>
<span class="sd">            coordinate arrays. Or, if it&#39;s just a list or tuple of</span>
<span class="sd">            integers, those integers are taken to be the nz,ny,nx shape</span>
<span class="sd">            and the coordinates will be fill with :py:func:`np.arange`.</span>
<span class="sd">        fill_value (number, None): Initial value of array. None</span>
<span class="sd">            indicates uninitialized (i.e., `numpy.empty`)</span>
<span class="sd">        dtype (optional): some way to describe numpy dtype of data</span>
<span class="sd">        name (str): a way to refer to the field programatically</span>
<span class="sd">        center (str, optional): cell or node, there really isn&#39;t</span>
<span class="sd">            support for edge / face yet</span>
<span class="sd">        layout (str, optional): how data is stored, is in &quot;flat&quot; or</span>
<span class="sd">            &quot;interlaced&quot; (interlaced == AOS)</span>
<span class="sd">        nr_comps (int, optional): for vector fields, nr of components</span>
<span class="sd">        **kwargs: passed through to Field constructor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crds</span><span class="p">,</span> <span class="n">coordinate</span><span class="o">.</span><span class="n">Coordinates</span><span class="p">):</span>
        <span class="c1"># if crds is a list/tuple of integers, then make coordinate</span>
        <span class="c1"># arrays using arange</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crds</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">crds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">crds</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">crds</span> <span class="o">=</span> <span class="p">[</span><span class="n">crds</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">crds</span><span class="p">]):</span>
            <span class="n">crds</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">crds</span><span class="p">]</span>
        <span class="c1"># now assume that crds is a list of coordinate arrays that arrays2crds</span>
        <span class="c1"># can understand</span>
        <span class="n">crds</span> <span class="o">=</span> <span class="n">coordinate</span><span class="o">.</span><span class="n">arrays2crds</span><span class="p">(</span><span class="n">crds</span><span class="p">,</span> <span class="n">crd_type</span><span class="o">=</span><span class="n">crd_type</span><span class="p">,</span> <span class="n">crd_names</span><span class="o">=</span><span class="n">crd_names</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">center</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;cell&quot;</span><span class="p">:</span>
        <span class="n">sshape</span> <span class="o">=</span> <span class="n">crds</span><span class="o">.</span><span class="n">shape_cc</span>
    <span class="k">elif</span> <span class="n">center</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;node&quot;</span><span class="p">:</span>
        <span class="n">sshape</span> <span class="o">=</span> <span class="n">crds</span><span class="o">.</span><span class="n">shape_nc</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sshape</span> <span class="o">=</span> <span class="n">crds</span><span class="o">.</span><span class="n">shape_nc</span>

    <span class="k">if</span> <span class="n">nr_comps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">fldtype</span> <span class="o">=</span> <span class="s2">&quot;scalar&quot;</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">sshape</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fldtype</span> <span class="o">=</span> <span class="s2">&quot;vector&quot;</span>
        <span class="k">if</span> <span class="n">layout</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">LAYOUT_INTERLACED</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sshape</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">nr_comps</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">nr_comps</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">sshape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s2">&quot;full&quot;</span><span class="p">):</span>
            <span class="n">dat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s2">&quot;filled&quot;</span><span class="p">):</span>
            <span class="n">dat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Please update Numpy; your version has neither &quot;</span>
                               <span class="s2">&quot;`numpy.full` nor `numpy.filled`&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrap_field</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">crds</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">fldtype</span><span class="o">=</span><span class="n">fldtype</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="empty"><a class="viewcode-back" href="../../api/viscid.field.html#viscid.empty">[docs]</a><span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="n">crds</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;f8&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;NoName&quot;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s2">&quot;cell&quot;</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">LAYOUT_FLAT</span><span class="p">,</span>
          <span class="n">nr_comps</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Analogous to `numpy.empty`</span>

<span class="sd">    Returns:</span>
<span class="sd">        new uninitialized :class:`Field`</span>

<span class="sd">    See Also: :meth:`full`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">full</span><span class="p">(</span><span class="n">crds</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                <span class="n">layout</span><span class="o">=</span><span class="n">layout</span><span class="p">,</span> <span class="n">nr_comps</span><span class="o">=</span><span class="n">nr_comps</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="zeros"><a class="viewcode-back" href="../../api/viscid.field.html#viscid.zeros">[docs]</a><span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="n">crds</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;f8&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;NoName&quot;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s2">&quot;cell&quot;</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">LAYOUT_FLAT</span><span class="p">,</span>
          <span class="n">nr_comps</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Analogous to `numpy.zeros`</span>

<span class="sd">    Returns:</span>
<span class="sd">        new :class:`Field` initialized to 0</span>

<span class="sd">    See Also: :meth:`full`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">full</span><span class="p">(</span><span class="n">crds</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                <span class="n">layout</span><span class="o">=</span><span class="n">layout</span><span class="p">,</span> <span class="n">nr_comps</span><span class="o">=</span><span class="n">nr_comps</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="ones"><a class="viewcode-back" href="../../api/viscid.field.html#viscid.ones">[docs]</a><span class="k">def</span> <span class="nf">ones</span><span class="p">(</span><span class="n">crds</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;f8&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;NoName&quot;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s2">&quot;cell&quot;</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">LAYOUT_FLAT</span><span class="p">,</span>
         <span class="n">nr_comps</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Analogous to `numpy.ones`</span>

<span class="sd">    Returns:</span>
<span class="sd">        new :class:`Field` initialized to 1</span>

<span class="sd">    See Also: :meth:`full`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">full</span><span class="p">(</span><span class="n">crds</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                <span class="n">layout</span><span class="o">=</span><span class="n">layout</span><span class="p">,</span> <span class="n">nr_comps</span><span class="o">=</span><span class="n">nr_comps</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="full_like"><a class="viewcode-back" href="../../api/viscid.field.html#viscid.full_like">[docs]</a><span class="k">def</span> <span class="nf">full_like</span><span class="p">(</span><span class="n">fld</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;NoName&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Analogous to `numpy.full_like`</span>

<span class="sd">    Makes a new :class:`Field` initialized to fill_value. Copies as</span>
<span class="sd">    much meta data as it can from `fld`.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        fld: field to get coordinates / metadata from</span>
<span class="sd">        fill_value (number, None): initial value, or None to leave</span>
<span class="sd">            data uninitialized</span>
<span class="sd">        name: name for this field</span>
<span class="sd">        **kwargs: passed through to :class:`Field` constructor</span>

<span class="sd">    Returns:</span>
<span class="sd">        new :class:`Field`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">fld</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">fld</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s2">&quot;full&quot;</span><span class="p">):</span>
            <span class="n">dat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">fld</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">fld</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s2">&quot;filled&quot;</span><span class="p">):</span>
            <span class="n">dat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fld</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">fld</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Please update Numpy; your version has neither &quot;</span>
                               <span class="s2">&quot;`numpy.full` nor `numpy.filled`&quot;</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">fld</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">fld</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrap_field</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">fld</span><span class="o">.</span><span class="n">crds</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">fldtype</span><span class="o">=</span><span class="n">fld</span><span class="o">.</span><span class="n">fldtype</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                      <span class="n">time</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="p">[</span><span class="n">fld</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="empty_like"><a class="viewcode-back" href="../../api/viscid.field.html#viscid.empty_like">[docs]</a><span class="k">def</span> <span class="nf">empty_like</span><span class="p">(</span><span class="n">fld</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Analogous to `numpy.empty_like`</span>

<span class="sd">    Returns:</span>
<span class="sd">        new uninitialized :class:`Field`</span>

<span class="sd">    See Also: :meth:`full_like`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">full_like</span><span class="p">(</span><span class="n">fld</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="zeros_like"><a class="viewcode-back" href="../../api/viscid.field.html#viscid.zeros_like">[docs]</a><span class="k">def</span> <span class="nf">zeros_like</span><span class="p">(</span><span class="n">fld</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Analogous to `numpy.zeros_like`</span>

<span class="sd">    Returns:</span>
<span class="sd">        new :class:`Field` filled with zeros</span>

<span class="sd">    See Also: :meth:`full_like`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">full_like</span><span class="p">(</span><span class="n">fld</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="ones_like"><a class="viewcode-back" href="../../api/viscid.field.html#viscid.ones_like">[docs]</a><span class="k">def</span> <span class="nf">ones_like</span><span class="p">(</span><span class="n">fld</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Analogous to `numpy.ones_like`</span>

<span class="sd">    Returns:</span>
<span class="sd">        new :class:`Field` filled with ones</span>

<span class="sd">    See Also: :meth:`full_like`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">full_like</span><span class="p">(</span><span class="n">fld</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">_mfield_factory</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This mimics Numpy&#39;s mgrid and ogrid functionality&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;node&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slc</span><span class="p">):</span>
        <span class="n">crd_arrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="n">slc</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">zeros</span><span class="p">(</span><span class="n">crd_arrs</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>


<span class="n">mfield_cell</span> <span class="o">=</span> <span class="n">_mfield_factory</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">mfield_node</span> <span class="o">=</span> <span class="n">_mfield_factory</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="s1">&#39;node&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">mfield</span> <span class="o">=</span> <span class="n">mfield_node</span>

<div class="viewcode-block" id="scalar_fields_to_vector"><a class="viewcode-back" href="../../api/viscid.field.html#viscid.scalar_fields_to_vector">[docs]</a><span class="k">def</span> <span class="nf">scalar_fields_to_vector</span><span class="p">(</span><span class="n">fldlist</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;NoName&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert scalar fields to a vector field</span>

<span class="sd">    Parameters:</span>
<span class="sd">        name (str): name for the vector field</span>
<span class="sd">        fldlist: list of :class:`ScalarField`</span>
<span class="sd">        **kwargs: passed to :class:`VectorField` constructor</span>

<span class="sd">    Returns:</span>
<span class="sd">        A new :class:`VectorField`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">fldlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">fldlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">center</span>
    <span class="n">crds</span> <span class="o">=</span> <span class="n">fldlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_src_crds</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">fldlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">time</span>
    <span class="c1"># shape = fldlist[0].data.shape</span>

    <span class="n">_crds</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">crds</span><span class="p">)(</span><span class="n">crds</span><span class="o">.</span><span class="n">get_clist</span><span class="p">())</span>

    <span class="c1"># component fields will already be transposed when filling caches, so</span>
    <span class="c1"># the source will already be xyz</span>
    <span class="k">if</span> <span class="s2">&quot;zyx_native&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;zyx_native&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;did you really want to do another transpose?&quot;</span><span class="p">)</span>

    <span class="n">vfield</span> <span class="o">=</span> <span class="n">VectorField</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">_crds</span><span class="p">,</span> <span class="n">fldlist</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                         <span class="n">meta</span><span class="o">=</span><span class="n">fldlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="p">[</span><span class="n">fldlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vfield</span></div>

<span class="k">def</span> <span class="nf">field_type</span><span class="p">(</span><span class="n">fldtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Lookup a Field type</span>

<span class="sd">    The magic lookup happens when fldtype is a string, if fldtype is a class</span>
<span class="sd">    then just return the class for convenience.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        fldtype: python class object or string describing a field type in</span>
<span class="sd">            some way</span>

<span class="sd">    Returns:</span>
<span class="sd">        a :class:`Field` subclass</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">isclass</span><span class="p">(</span><span class="n">fldtype</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">fldtype</span><span class="p">,</span> <span class="n">Field</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fldtype</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">subclass_spider</span><span class="p">(</span><span class="n">Field</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">istype</span><span class="p">(</span><span class="n">fldtype</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">cls</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Field type </span><span class="si">{0}</span><span class="s2"> not understood&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fldtype</span><span class="p">))</span>
    <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="wrap_field"><a class="viewcode-back" href="../../api/viscid.field.html#viscid.wrap_field">[docs]</a><span class="k">def</span> <span class="nf">wrap_field</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">crds</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;NoName&quot;</span><span class="p">,</span> <span class="n">fldtype</span><span class="o">=</span><span class="s2">&quot;scalar&quot;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;node&#39;</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convenience script for wrapping ndarrays</span>

<span class="sd">    Parameters:</span>
<span class="sd">        data: Some data container, most likely a ``numpy.ndarray``</span>
<span class="sd">        crds (Coordinates): coordinates that describe the shape / grid</span>
<span class="sd">            of the field</span>
<span class="sd">        fldtype (str): &#39;scalar&#39; / &#39;Vector&#39;</span>
<span class="sd">        name (str): a way to refer to the field programatically</span>
<span class="sd">        **kwargs: passed through to :class:`Field` constructor</span>

<span class="sd">    Returns:</span>
<span class="sd">        A :class:`Field` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># try to auto-detect vector fields</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;node&#39;</span> <span class="ow">and</span>
            <span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">crds</span><span class="o">.</span><span class="n">shape_nc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
            <span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">crds</span><span class="o">.</span><span class="n">shape_nc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">fldtype</span> <span class="o">=</span> <span class="s2">&quot;vector&quot;</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span> <span class="ow">and</span>
              <span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">crds</span><span class="o">.</span><span class="n">shape_cc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
              <span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">crds</span><span class="o">.</span><span class="n">shape_cc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">fldtype</span> <span class="o">=</span> <span class="s2">&quot;vector&quot;</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="bp">cls</span> <span class="o">=</span> <span class="n">field_type</span><span class="p">(</span><span class="n">fldtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">crds</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;can not decipher field&quot;</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">rewrap_field</span><span class="p">(</span><span class="n">fld</span><span class="p">):</span>
    <span class="c1"># zyx_native is false b/c we&#39;re using fld.data</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">fld</span><span class="p">)(</span><span class="n">fld</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">fld</span><span class="o">.</span><span class="n">crds</span><span class="p">,</span> <span class="n">fld</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">fld</span><span class="o">.</span><span class="n">center</span><span class="p">,</span>
                    <span class="n">forget_source</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">_copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">zyx_native</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">parents</span><span class="o">=</span><span class="p">[</span><span class="n">fld</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">class</span> <span class="nc">_FldSlcProxy</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">do_floatify</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_floatify</span> <span class="o">=</span> <span class="n">do_floatify</span>

    <span class="k">def</span> <span class="nf">_floatify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="n">dt_re</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(\s*</span><span class="si">{0}</span><span class="s2">\s*)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">viscid</span><span class="o">.</span><span class="n">sliceutil</span><span class="o">.</span><span class="n">RE_DTIME_SLC_GROUP</span><span class="p">)</span>
            <span class="n">datetimes</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">dt_re</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">dt_re</span><span class="p">,</span> <span class="s1">&#39;__DATETIME__&#39;</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([\d\.e]+(?![\d\.FfJj]))&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1j&#39;</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="n">item_split</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;__DATETIME__&#39;</span><span class="p">)</span>
            <span class="n">item</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item_split</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">datetimes</span><span class="p">))</span>
            <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">item_split</span>
            <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">datetimes</span>
            <span class="n">item</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">Ellipsis</span><span class="p">,</span> <span class="s1">&#39;...&#39;</span><span class="p">):</span>
            <span class="n">item</span> <span class="o">=</span> <span class="bp">Ellipsis</span>
        <span class="k">elif</span> <span class="n">item</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">):</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span>
        <span class="k">elif</span> <span class="n">item</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;none&#39;</span><span class="p">):</span>
            <span class="n">item</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_floatify</span><span class="p">:</span>
                <span class="n">item</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">item</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,)):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
                <span class="c1"># try:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_floatify</span><span class="p">:</span>
                    <span class="n">item</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="c1"># except (ValueError, TypeError):</span>
                <span class="c1">#     pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_floatify</span><span class="p">:</span>
                <span class="n">item</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">item</span>

    <span class="k">def</span> <span class="nf">_xform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">item</span> <span class="o">=</span> <span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">)</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floatify</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floatify</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
                <span class="n">step</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">step</span>
                <span class="n">sel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_floatify</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">nr_comps</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">nr_comp</span><span class="p">:</span>
            <span class="n">sel</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">nr_comp</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xform</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xform</span><span class="p">(</span><span class="n">item</span><span class="p">),</span> <span class="n">val</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Field</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">Leaf</span><span class="p">):</span>
    <span class="n">_TYPE</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span>
    <span class="n">_CENTERING</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;node&#39;</span><span class="p">,</span> <span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="s1">&#39;face&#39;</span><span class="p">,</span> <span class="s1">&#39;edge&#39;</span><span class="p">]</span>

    <span class="c1"># set on __init__</span>
    <span class="c1"># NOTE: _src_data is allowed by be a list to support creating vectors from</span>
    <span class="c1"># some scalar fields without necessarilly loading the data</span>
    <span class="n">_center</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span>  <span class="c1"># String in CENTERING</span>
    <span class="n">_src_data</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># numpy-like object (h5py too), or list of these objects</span>

    <span class="n">_src_crds</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Coordinate object</span>
    <span class="n">_crds</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Coordinate object</span>

    <span class="c1"># dict, this stuff will be copied by self.wrap</span>
    <span class="n">meta</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1">#</span>
    <span class="c1"># dict, used for stuff that won&#39;t be blindly copied by self.wrap</span>
    <span class="n">deep_meta</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">pretty_name</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># String</span>

    <span class="n">post_reshape_transform_func</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">transform_func_kwargs</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">defer_wrapping</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># _parent_field is a hacky way to keep a &#39;parent&#39; field in sync when data</span>
    <span class="c1"># is loaded... this is used for converting cell centered data -&gt;</span>
    <span class="c1"># node centered and back... this only works because _fill_cache</span>
    <span class="c1"># ONLY sets self._cache... if other meta data were set by</span>
    <span class="c1"># _fill_cache, that would need to propogate upstream too</span>
    <span class="n">_parent_field</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># these get reset when data is set</span>
    <span class="n">_layout</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_nr_comps</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_nr_comp</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_dtype</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># set when data is retrieved</span>
    <span class="n">_cache</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># this will always be a numpy array</span>
    <span class="n">_cached_xyz_src_view</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">crds</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s2">&quot;Node&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">deep_meta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">forget_source</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pretty_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">post_reshape_transform_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">transform_func_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_parent_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            parents: Dataset, Grid, Field, or list of any of</span>
<span class="sd">                those. These parents are the sources for find_info, and</span>
<span class="sd">                and monkey-pached methods.</span>
<span class="sd">            _parent_field (Field): special parent where data can be taken</span>
<span class="sd">                for lazy loading. This field is added to parents</span>
<span class="sd">                automatically</span>

<span class="sd">        Other Parameters:</span>
<span class="sd">            kwargs with a leading underscore (like _copy) are added to</span>
<span class="sd">            the deep_meta dict without the leading _. Everything else</span>
<span class="sd">            is added to the meta dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if name == &quot;b&quot;:</span>
        <span class="c1">#     print(&quot;initing b&quot;)</span>
        <span class="c1">#     import pdb; pdb.set_trace()</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Field</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">parents</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span> <span class="o">=</span> <span class="n">crds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">comp_names</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="k">if</span> <span class="n">pretty_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pretty_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pretty_name</span> <span class="o">=</span> <span class="n">pretty_name</span>

        <span class="c1"># # i think this is a mistake</span>
        <span class="c1"># if isinstance(data, (list, tuple)) and isinstance(data[0], Field):</span>
        <span class="c1">#     if post_reshape_transform_func is None:</span>
        <span class="c1">#         post_reshape_transform_func = data[0].post_reshape_transform_func</span>
        <span class="c1">#     if transform_func_kwargs is None:</span>
        <span class="c1">#         transform_func_kwargs = data[0].transform_func_kwargs</span>

        <span class="k">if</span> <span class="n">post_reshape_transform_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">post_reshape_transform_func</span> <span class="o">=</span> <span class="n">post_reshape_transform_func</span>
        <span class="k">if</span> <span class="n">transform_func_kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transform_func_kwargs</span> <span class="o">=</span> <span class="n">transform_func_kwargs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transform_func_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">meta</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deep_meta</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">deep_meta</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">deep_meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deep_meta</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">if</span> <span class="s2">&quot;force_layout&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deep_meta</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;force_layout&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;deprecated force_layout syntax: kwarg should &quot;</span>
                               <span class="s2">&quot;be given as _force_layout&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deep_meta</span><span class="p">[</span><span class="s2">&quot;force_layout&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;force_layout&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deep_meta</span><span class="p">[</span><span class="s2">&quot;force_layout&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LAYOUT_DEFAULT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deep_meta</span><span class="p">[</span><span class="s2">&quot;force_layout&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deep_meta</span><span class="p">[</span><span class="s2">&quot;force_layout&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="s2">&quot;copy&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deep_meta</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deep_meta</span><span class="p">[</span><span class="s2">&quot;copy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parent_field</span> <span class="o">=</span> <span class="n">_parent_field</span>
        <span class="k">if</span> <span class="n">_parent_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_parent_field</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">forget_source</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forget_source</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fldtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TYPE</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center</span>
    <span class="nd">@center</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_center</span><span class="p">):</span>
        <span class="n">new_center</span> <span class="o">=</span> <span class="n">new_center</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">new_center</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CENTERING</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_center</span> <span class="o">=</span> <span class="n">new_center</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">layout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get the layout type, &#39;interlaced&#39; (AOS) | &#39;flat (SOA)&#39;. This at most</span>
<span class="sd">        calls _detect_layout(_src_data) which tries to be lazy &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">deep_meta</span><span class="p">[</span><span class="s2">&quot;force_layout&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">LAYOUT_DEFAULT</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_layout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deep_meta</span><span class="p">[</span><span class="s2">&quot;force_layout&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_layout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_layout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layout</span>

    <span class="nd">@layout</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">layout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_layout</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; UNTESTED, clear cache if layout changes &quot;&quot;&quot;</span>
        <span class="n">new_layout</span> <span class="o">=</span> <span class="n">new_layout</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_loaded</span><span class="p">:</span>
            <span class="n">current_layout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layout</span>
            <span class="k">if</span> <span class="n">new_layout</span> <span class="o">!=</span> <span class="n">current_layout</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">clear_cache</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deep_meta</span><span class="p">[</span><span class="s2">&quot;force_layout&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_layout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layout</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nr_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns number of dims, this should be the number of dims of</span>
<span class="sd">        the underlying data, but is assumed a priori so no data load is</span>
<span class="sd">        done here &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_sdims</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_dims</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nr_sdims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; number of spatial dims, same as crds.nr_dims, does not</span>
<span class="sd">        explicitly load the data &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">nr_dims</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nr_comps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; how many components are there? Only inspects _src_data &quot;&quot;&quot;</span>
        <span class="c1"># this gets # of comps from src_data, so layout is given as layout</span>
        <span class="c1"># of src_data since it might not be loaded yet</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nr_comps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">layout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_layout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">layout</span> <span class="o">==</span> <span class="n">LAYOUT_INTERLACED</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                    <span class="c1"># this is an awkward way to get the data in here...</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_nr_comps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_nr_comps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">layout</span> <span class="o">==</span> <span class="n">LAYOUT_FLAT</span><span class="p">:</span>
                <span class="c1"># length of 1st dim... this works for ndarrays &amp;&amp; lists</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_nr_comps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">layout</span> <span class="o">==</span> <span class="n">LAYOUT_SCALAR</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_nr_comps</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Could not detect data layout; &quot;</span>
                                   <span class="s2">&quot;can&#39;t give nr_comps&quot;</span><span class="p">)</span>
                <span class="c1"># return self._src_data.shape[-1]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nr_comps</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nr_comp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; dimension of the components of the vector, loads the data if</span>
<span class="sd">        self.layout does &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nr_comp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">layout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layout</span>
            <span class="k">if</span> <span class="n">layout</span> <span class="o">==</span> <span class="n">LAYOUT_FLAT</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_nr_comp</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">layout</span> <span class="o">==</span> <span class="n">LAYOUT_INTERLACED</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_nr_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">nr_dims</span>
            <span class="k">elif</span> <span class="n">layout</span> <span class="o">==</span> <span class="n">LAYOUT_SCALAR</span><span class="p">:</span>
                <span class="c1"># use same as interlaced for slicing convenience, note</span>
                <span class="c1"># this is only for a one component vector, for scalars</span>
                <span class="c1"># nr_comp is None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_nr_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">nr_dims</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Could not detect data layout; &quot;</span>
                                   <span class="s2">&quot;can&#39;t give nr_comp&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nr_comp</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns the shape of the underlying data, does not explicitly load</span>
<span class="sd">        the data &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sshape</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_comp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comps</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">native_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns the shape of the underlying data, does not explicitly load</span>
<span class="sd">        the data &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">native_sshape</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_comp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comps</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sshape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; shape of spatial dimensions, does not include comps, and is not</span>
<span class="sd">        the same shape as underlying array, does not load the data &quot;&quot;&quot;</span>
        <span class="c1"># it is enforced that the cached data has a shape that agrees with</span>
        <span class="c1"># the coords by _reshape_ndarray_to_crds... actually, that method</span>
        <span class="c1"># requires this method to depend on the crd shape</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s2">&quot;node&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">shape_nc</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s2">&quot;cell&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">shape_cc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># logger.warning(&quot;edge/face vectors not implemented, assuming &quot;</span>
            <span class="c1">#                &quot;cell shape&quot;)</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">shape_cc</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">native_sshape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sshape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sshape</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zyx_native&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">sshape</span> <span class="o">=</span> <span class="n">sshape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sshape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; how many values are in underlying data &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ssize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; how many values make up one component of the underlying data &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sshape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># print(type(self._src_data))</span>
        <span class="c1"># dtype.name is for pruning endianness out of dtype</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="o">.</span><span class="n">dtype</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">crds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_crds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">apply_reflections</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crds</span>

    <span class="nd">@crds</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">crds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_crds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; if you want to fill the cache, this will do it, note that</span>
<span class="sd">        to empty the cache later you can always use clear_cache &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fill_cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span>
    <span class="nd">@data</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dat</span><span class="p">):</span>
        <span class="c1"># clean up</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear_cache</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layout</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nr_comp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nr_comps</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span> <span class="o">=</span> <span class="n">dat</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;zyx_native&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;zyx_native&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># self._translate_src_data()  # um, what&#39;s this for? looks dangerous</span>
        <span class="c1"># do some sort of lazy pre-setup _src_data inspection?</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flat_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">patches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nr_patches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pylint: disable=no-self-use</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">crds</span><span class="o">.</span><span class="n">xl_nc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">crds</span><span class="o">.</span><span class="n">xh_nc</span>

    <span class="k">def</span> <span class="nf">get_slice_extent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection</span><span class="p">):</span>
        <span class="n">extent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">patches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_slice_extent</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]):</span>
                <span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]):</span>
                <span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">extent</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_loaded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">clear_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; does not guarentee that the memory will be freed &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cached_xyz_src_view</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent_field</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent_field</span><span class="o">.</span><span class="n">_cached_xyz_src_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_xyz_src_view</span>

    <span class="k">def</span> <span class="nf">_fill_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; actually load data into the cache &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_data_to_ndarray</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent_field</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span>
            <span class="c1"># self._parent_field._cached_xyz_src_view = self._cached_xyz_src_view</span>

    <span class="k">def</span> <span class="nf">resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resolve all pending actions on a field like translations etc&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fill_cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># um, what was this for? looks dangerous</span>
    <span class="c1"># def _translate_src_data(self):</span>
    <span class="c1">#     pass</span>

    <span class="c1"># @staticmethod</span>
    <span class="c1"># def _zyx_transpose(dat):</span>
    <span class="c1">#     if isinstance(dat, Field):</span>
    <span class="c1">#         pass</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         return dat.T</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_xyz_src_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a view of _src_data that is xyz ordered</span>

<span class="sd">        Note that this will always cause the cache to be filled</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_xyz_src_view</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zyx_native&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                    <span class="c1"># lst = [np.array(d).T for d in self._src_data]</span>
                    <span class="c1"># self._cached_xyz_src_view = lst</span>

                    <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">:</span>
                        <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                        <span class="c1"># Slight memory hack: clear cache on src data, there</span>
                        <span class="c1"># probably exists a better way to be more lazy</span>
                        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s2">&quot;clear_cache&quot;</span><span class="p">):</span>
                            <span class="n">d</span><span class="o">.</span><span class="n">clear_cache</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cached_xyz_src_view</span> <span class="o">=</span> <span class="n">lst</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># spatial_transpose = list(range(len(self.shape)))</span>
                    <span class="n">spatial_transpose</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">nr_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comp</span>
                        <span class="n">spatial_transpose</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">nr_comp</span><span class="p">)</span>
                        <span class="n">spatial_transpose</span> <span class="o">=</span> <span class="n">spatial_transpose</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">spatial_transpose</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nr_comp</span><span class="p">,</span> <span class="n">nr_comp</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">spatial_transpose</span> <span class="o">=</span> <span class="n">spatial_transpose</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="c1"># transposed view</span>
                    <span class="n">Tview</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="o">.</span><span class="n">__array__</span><span class="p">(),</span>
                                         <span class="n">spatial_transpose</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cached_xyz_src_view</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Tview</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cached_xyz_src_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_xyz_src_view</span>

    <span class="k">def</span> <span class="nf">_src_data_to_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; prep the src data into something usable and enforce a layout &quot;&quot;&quot;</span>
        <span class="c1"># some magic may need to happen here to accept more than np/h5 data</span>
        <span class="c1"># override if a type does something fancy (eg, interlacing)</span>
        <span class="c1"># and dat.flags[&quot;OWNDATA&quot;]  # might i want this?</span>
        <span class="n">src_data_layout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_layout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">)</span>
        <span class="n">force_layout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deep_meta</span><span class="p">[</span><span class="s2">&quot;force_layout&quot;</span><span class="p">]</span>

        <span class="c1"># we will preserve layout or we already have the correct layout,</span>
        <span class="c1"># do no translation</span>
        <span class="k">if</span> <span class="n">force_layout</span> <span class="o">==</span> <span class="n">LAYOUT_DEFAULT</span> <span class="ow">or</span> \
           <span class="n">force_layout</span> <span class="o">==</span> <span class="n">src_data_layout</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dat_to_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xyz_src_data</span><span class="p">)</span>

        <span class="c1"># if layout is found to be other, i cant do anything with that</span>
        <span class="k">elif</span> <span class="n">src_data_layout</span> <span class="o">==</span> <span class="n">LAYOUT_OTHER</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Cannot auto-detect layout; not translating; &quot;</span>
                           <span class="s2">&quot;performance may suffer&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dat_to_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xyz_src_data</span><span class="p">)</span>

        <span class="c1"># ok, we demand FLAT arrays, make it so</span>
        <span class="k">elif</span> <span class="n">force_layout</span> <span class="o">==</span> <span class="n">LAYOUT_FLAT</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">src_data_layout</span> <span class="o">!=</span> <span class="n">LAYOUT_INTERLACED</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;I should not be here&quot;</span><span class="p">)</span>

            <span class="n">nr_comps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comps</span>
            <span class="n">data_dest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_comps</span><span class="p">):</span>
                <span class="c1"># NOTE: I wonder if this is the fastest way to reorder</span>
                <span class="n">data_dest</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xyz_src_data</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                <span class="c1"># NOTE: no special case for lists, they are not</span>
                <span class="c1"># interpreted this way</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dat_to_ndarray</span><span class="p">(</span><span class="n">data_dest</span><span class="p">)</span>

        <span class="c1"># ok, we demand INTERLACED arrays, make it so</span>
        <span class="k">elif</span> <span class="n">force_layout</span> <span class="o">==</span> <span class="n">LAYOUT_INTERLACED</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">src_data_layout</span> <span class="o">!=</span> <span class="n">LAYOUT_FLAT</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;I should not be here&quot;</span><span class="p">)</span>

            <span class="n">nr_comps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comps</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
            <span class="n">data_dest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_comps</span><span class="p">):</span>
                <span class="n">data_dest</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xyz_src_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_layout</span> <span class="o">=</span> <span class="n">LAYOUT_INTERLACED</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dat_to_ndarray</span><span class="p">(</span><span class="n">data_dest</span><span class="p">)</span>

        <span class="c1"># catch the remaining cases</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">deep_meta</span><span class="p">[</span><span class="s2">&quot;force_layout&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">LAYOUT_OTHER</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;How should I know how to force other layout?&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bad argument for layout forcing&quot;</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;I should not be here&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_dat_to_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This should be the last thing called for all data that gets put</span>
<span class="sd">        into the cache. It makes dimensions jive correctly. This will translate</span>
<span class="sd">        non-ndarray data structures to a flat ndarray. Also, this function</span>
<span class="sd">        makes damn sure that the dimensionality of the coords matches the</span>
<span class="sd">        dimensionality of the array, which is to say, if the array is only 2d,</span>
<span class="sd">        but the coords have a 3rd dimension with length 1, reshape the array</span>
<span class="sd">        to include that extra dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># dtype.name is for pruning endianness out of dtype</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">arrfunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                <span class="n">arrfunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arrfunc</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dat</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">deep_meta</span><span class="p">[</span><span class="s2">&quot;copy&quot;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">dat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span>
            <span class="c1"># tmp = [np.array(d, dtype=dt, copy=self.deep_meta[&quot;copy&quot;]) for d in dat]</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dat</span><span class="p">:</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">deep_meta</span><span class="p">[</span><span class="s2">&quot;copy&quot;</span><span class="p">]))</span>
                <span class="c1"># Slight memory hack: clear cache on src data, there</span>
                <span class="c1"># probably exists a better way to be more lazy</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s2">&quot;clear_cache&quot;</span><span class="p">):</span>
                    <span class="n">d</span><span class="o">.</span><span class="n">clear_cache</span><span class="p">()</span>
            <span class="n">_shape</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="p">)]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">_shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tmp</span><span class="p">):</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
        <span class="c1"># elif isinstance(dat, Field):</span>
        <span class="c1">#     arr = dat.data  # not the way</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dat</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">deep_meta</span><span class="p">[</span><span class="s2">&quot;copy&quot;</span><span class="p">])</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reshape_ndarray_to_crds</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">nr_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comp</span>
            <span class="n">nr_comps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comps</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">nr_comp</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">nr_comps</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># FIXME, there should be a flag for whether or not this should</span>
        <span class="c1"># make a copy of the array if it&#39;s not contiguous in memory</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">reflect_fld_arr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s2">&quot;Cell&quot;</span><span class="p">),</span>
                                             <span class="n">nr_comp</span><span class="p">,</span> <span class="n">nr_comps</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_reshape_transform_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_reshape_transform_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span>
                                                   <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_func_kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">arr</span>

    <span class="k">def</span> <span class="nf">_reshape_ndarray_to_crds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; enforce same dimensionality as coords here!</span>
<span class="sd">        self.shape better still be using the crds shape corrected for</span>
<span class="sd">        node / cell centering</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_detect_layout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dat</span><span class="p">,</span> <span class="n">native</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns LAYOUT_XXX, this just looks at len(dat) or dat.shape</span>
<span class="sd">        Note:</span>
<span class="sd">            dat should be in &#39;native layout&#39;, meaning zyx is _src_data is</span>
<span class="sd">            zyx, or xyz if _src_data is xyz</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if native, then compare dat&#39;s shape against the native shape</span>
        <span class="k">if</span> <span class="n">native</span><span class="p">:</span>
            <span class="n">sshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">native_sshape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sshape</span><span class="p">)</span>

        <span class="c1"># if i receive a list, then i suppose i have a list of</span>
        <span class="c1"># arrays, one for each component... this is a flat layout</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="c1"># Make sure the list makes sense... this strictly speaking</span>
            <span class="c1"># doesn&#39;t need to happen, but it&#39;s a bad habbit to allow</span>
            <span class="c1"># shapes through that I don&#39;t explicitly plan for, since</span>
            <span class="c1"># this is just the door to the rabbit hole</span>
            <span class="c1"># BUT, this has the side effect that one can&#39;t create vector</span>
            <span class="c1"># fields with vx = Xcc, one has to use</span>
            <span class="c1"># vx = Xcc + 0 * Ycc + 0 * Zcc, which is rather cumbersome</span>
            <span class="c1"># for d in dat:</span>
            <span class="c1">#     assert(list(d.shape) == list(sshape))</span>
            <span class="k">return</span> <span class="n">LAYOUT_FLAT</span>

        <span class="n">dat_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dat_shape</span> <span class="o">==</span> <span class="n">sshape</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">LAYOUT_SCALAR</span>

        <span class="c1"># if the crds shape has more values than the dat.shape</span>
        <span class="c1"># then try trimming the directions that have 1 element</span>
        <span class="c1"># this can happen when crds are 3d, but field is only 2d</span>
        <span class="c1">## I&#39;m not sure why this needs to happen... but tests fail</span>
        <span class="c1">## without it</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">sshape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">dat_shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sshape</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># check which dims match the shape of the crds</span>
        <span class="c1"># or if they match when disregarding length 1 axes.</span>
        <span class="c1"># This 2nd part happens when calling atleast_3d() on</span>
        <span class="c1"># a field that isn&#39;t already in memory</span>
        <span class="n">dat_shape2</span> <span class="o">=</span> <span class="p">[</span><span class="n">si</span> <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">dat_shape</span> <span class="k">if</span> <span class="n">si</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">sshape2</span> <span class="o">=</span> <span class="p">[</span><span class="n">si</span> <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">dat_shape</span> <span class="k">if</span> <span class="n">si</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">dat_shape</span> <span class="o">==</span> <span class="n">sshape</span><span class="p">:</span>
            <span class="n">layout</span> <span class="o">=</span> <span class="n">LAYOUT_SCALAR</span>
        <span class="k">elif</span> <span class="n">dat_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">sshape</span><span class="p">:</span>
            <span class="n">layout</span> <span class="o">=</span> <span class="n">LAYOUT_FLAT</span>
        <span class="k">elif</span> <span class="n">dat_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">sshape</span> <span class="ow">or</span> <span class="n">dat_shape2</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">sshape2</span><span class="p">:</span>
            <span class="n">layout</span> <span class="o">=</span> <span class="n">LAYOUT_INTERLACED</span>
        <span class="k">elif</span> <span class="n">dat_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">sshape</span><span class="p">):</span>
            <span class="n">layout</span> <span class="o">=</span> <span class="n">LAYOUT_INTERLACED</span>
        <span class="k">elif</span> <span class="n">dat_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">sshape</span><span class="p">):</span>
            <span class="n">layout</span> <span class="o">=</span> <span class="n">LAYOUT_FLAT</span>
        <span class="c1"># the following are layouts that happen after a call to atleast_3d()</span>
        <span class="k">elif</span> <span class="n">dat_shape2</span> <span class="o">==</span> <span class="n">sshape2</span><span class="p">:</span>
            <span class="n">layout</span> <span class="o">=</span> <span class="n">LAYOUT_SCALAR</span>
        <span class="k">elif</span> <span class="n">dat_shape2</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">sshape2</span><span class="p">:</span>
            <span class="n">layout</span> <span class="o">=</span> <span class="n">LAYOUT_FLAT</span>
        <span class="k">elif</span> <span class="n">dat_shape2</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">sshape2</span><span class="p">:</span>
            <span class="n">layout</span> <span class="o">=</span> <span class="n">LAYOUT_INTERLACED</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if this happens, don&#39;t ignore it even if it happens to work</span>
            <span class="c1"># print(&quot;??&quot;, self, self.native_shape, self.shape, )</span>
            <span class="c1"># import pdb; pdb.set_trace()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;could not detect layout for &#39;</span><span class="si">{0}</span><span class="s2">&#39;: shape = </span><span class="si">{1}</span><span class="s2"> &quot;</span>
                         <span class="s2">&quot;target shape = </span><span class="si">{2}</span><span class="s2">&quot;</span>
                         <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dat_shape</span><span class="p">,</span> <span class="n">sshape</span><span class="p">))</span>
            <span class="n">layout</span> <span class="o">=</span> <span class="n">LAYOUT_OTHER</span>

        <span class="k">return</span> <span class="n">layout</span>

    <span class="k">def</span> <span class="nf">_prepare_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; if selection has a slice for component dimension, set it aside &quot;&quot;&quot;</span>
        <span class="n">sel_list</span> <span class="o">=</span> <span class="n">sliceutil</span><span class="o">.</span><span class="n">raw_sel2sel_list</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
        <span class="n">sel_list</span><span class="p">,</span> <span class="n">comp_slc</span> <span class="o">=</span> <span class="n">sliceutil</span><span class="o">.</span><span class="n">prune_comp_sel</span><span class="p">(</span><span class="n">sel_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp_names</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">layout</span> <span class="o">==</span> <span class="n">LAYOUT_SCALAR</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">comp_slc</span> <span class="o">==</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sel_list</span><span class="p">,</span> <span class="n">comp_slc</span>

    <span class="k">def</span> <span class="nf">_finalize_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slices</span><span class="p">,</span> <span class="n">crdlst</span><span class="p">,</span> <span class="n">reduced</span><span class="p">,</span> <span class="n">crd_type</span><span class="p">,</span> <span class="n">comp_slc</span><span class="p">):</span>
        <span class="c1"># if self.name == &quot;b&quot;:</span>
        <span class="c1">#     import pdb; pdb.set_trace()</span>
        <span class="n">all_none</span> <span class="o">=</span> <span class="n">sliceutil</span><span class="o">.</span><span class="n">all_slices_none</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span>
        <span class="n">no_sslices</span> <span class="o">=</span> <span class="n">slices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">all_none</span>
        <span class="n">no_compslice</span> <span class="o">=</span> <span class="n">comp_slc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">sliceutil</span><span class="o">.</span><span class="n">all_slices_none</span><span class="p">([</span><span class="n">comp_slc</span><span class="p">])</span>

        <span class="c1"># no slice necessary, just pass the field through</span>
        <span class="k">if</span> <span class="n">no_sslices</span> <span class="ow">and</span> <span class="n">no_compslice</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># if we&#39;re doing a component slice, and the underlying</span>
        <span class="c1"># data is a list/tuple of Field objects, we don&#39;t need</span>
        <span class="c1"># to do any more work</span>
        <span class="n">src_is_fld_list</span> <span class="o">=</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span>
                           <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Field</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">]))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">no_sslices</span> <span class="ow">and</span> <span class="n">src_is_fld_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_reshape_transform_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">[</span><span class="n">comp_slc</span><span class="p">]</span>

        <span class="c1"># IMPORTANT NOTE: from this point on, crds of the result will be</span>
        <span class="c1"># &quot;transformed&quot;, and the data will be xyz ordered. This is the end</span>
        <span class="c1"># of the line for lazily keeping track of zyx native arrays b/c</span>
        <span class="c1"># the slice will have to load the data</span>

        <span class="c1"># coord transforms are not copied on purpose</span>
        <span class="n">cunits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_units</span><span class="p">((</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">crdlst</span><span class="p">),</span> <span class="n">allow_invalid</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">crds</span> <span class="o">=</span> <span class="n">coordinate</span><span class="o">.</span><span class="n">wrap_crds</span><span class="p">(</span><span class="n">crd_type</span><span class="p">,</span> <span class="n">crdlst</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">cunits</span><span class="p">,</span>
                                    <span class="n">full_arrays</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">quiet_init</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">meta</span><span class="p">)</span>

        <span class="c1"># be intelligent here, if we haven&#39;t loaded the data and</span>
        <span class="c1"># the source is an h5py-like source, we don&#39;t have to read</span>
        <span class="c1"># the whole field; h5py will deal with the hyperslicing for us</span>
        <span class="n">slced_dat</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">hypersliceable</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">,</span> <span class="s2">&quot;_hypersliceable&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">single_comp_slc</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">comp_slc</span><span class="p">,</span> <span class="s2">&quot;__index__&quot;</span><span class="p">)</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s2">&quot;Cell&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s2">&quot;Face&quot;</span><span class="p">)</span> <span class="ow">or</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s2">&quot;Edge&quot;</span><span class="p">))</span>

        <span class="n">zyx_native</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zyx_native&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="c1"># if zyx_native:</span>
        <span class="c1">#     native_slices = slices[::-1]</span>
        <span class="c1"># else:</span>
        <span class="c1">#     native_slices = slices</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">src_is_fld_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">single_comp_slc</span><span class="p">:</span>
                <span class="c1"># this may not work as advertised since slices may</span>
                <span class="c1"># not be complete?</span>
                <span class="c1"># using xyz slices because it&#39;s calling Field.__getitem__</span>
                <span class="n">slced_dat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">[</span><span class="n">comp_slc</span><span class="p">][</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">comps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">[</span><span class="n">comp_slc</span><span class="p">]</span>
                <span class="c1"># using xyz slices because it&#39;s calling Field.__getitem__</span>
                <span class="n">slced_dat</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">hypersliceable</span><span class="p">:</span>
            <span class="c1"># we have to flip the slice, meaning: if the array looks like</span>
            <span class="c1"># ind     : 0    1     2    3    4    5    6</span>
            <span class="c1"># x       : -1.0 -0.5  0.0  0.5  1.0  1.5  2.0</span>
            <span class="c1"># -x[::-1]: -2.0 -1.5 -1.0 -0.5  0.0  0.5  1.0</span>
            <span class="c1"># if the slice is [-0.5:1.0], the crds figured out the slice</span>
            <span class="c1"># indices after doing -x[::-1], so the slice will be [3:7],</span>
            <span class="c1"># but in _src_dat, that data lives at indices [0:3]</span>
            <span class="c1"># so what we want is _src_data[::-1][3:6], but a more efficient</span>
            <span class="c1"># way to do this for large data sets is _src_data[0:3][::-1]</span>
            <span class="c1"># We will always read _src_data forward, then flip it since</span>
            <span class="c1"># h5py won&#39;t do a slice of [3:0:-1]</span>

            <span class="c1"># using xyz slices b/c that&#39;s the order of the crds</span>
            <span class="n">first_slc</span><span class="p">,</span> <span class="n">second_slc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">reflect_slices</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span>
                                                                  <span class="n">cc</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">zyx_native</span><span class="p">:</span>
                <span class="n">native_first_slc</span> <span class="o">=</span> <span class="n">first_slc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">native_second_slc</span> <span class="o">=</span> <span class="n">second_slc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">native_first_slc</span> <span class="o">=</span> <span class="n">first_slc</span>
                <span class="n">native_second_slc</span> <span class="o">=</span> <span class="n">second_slc</span>

            <span class="c1"># now put component slice back in</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">nr_comp</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nr_comp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_slc</span><span class="p">)</span>
                <span class="n">first_slc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nr_comp</span><span class="p">,</span> <span class="n">comp_slc</span><span class="p">)</span>
                <span class="n">native_first_slc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nr_comp</span><span class="p">,</span> <span class="n">comp_slc</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">single_comp_slc</span><span class="p">:</span>
                    <span class="n">second_slc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nr_comp</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
                    <span class="n">native_second_slc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nr_comp</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">nr_comp</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># this is a bad hack for the fact that fields and the slices</span>
            <span class="c1"># have 3 spatial dimensions, but the src_data may have fewer</span>
            <span class="n">_first</span><span class="p">,</span> <span class="n">_second</span> <span class="o">=</span> <span class="n">native_first_slc</span><span class="p">,</span> <span class="n">native_second_slc</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_first</span><span class="p">):</span>
                <span class="n">_first</span><span class="p">,</span> <span class="n">_second</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># trailing index</span>
                <span class="n">it</span> <span class="o">=</span> <span class="n">izip_longest</span><span class="p">(</span><span class="n">count</span><span class="p">(),</span> <span class="n">native_first_slc</span><span class="p">,</span> <span class="n">native_second_slc</span><span class="p">,</span>
                                  <span class="n">fillvalue</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">islice</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_slc</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">native_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">_first</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                        <span class="n">_second</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># ok, now cull out from the second slice</span>
            <span class="n">_second</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">_second</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

            <span class="c1"># only hyperslice _src_data if our slice has the right shape</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_first</span><span class="p">):</span>
                <span class="c1"># do the hyper-slice</span>
                <span class="c1"># these sliced have to be native b/c they&#39;re slicing the</span>
                <span class="c1"># _src_data directly which means the data could be stored</span>
                <span class="c1"># zyx in a lazy hdf5 file</span>
                <span class="n">slced_dat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">_first</span><span class="p">)][</span><span class="nb">tuple</span><span class="p">(</span><span class="n">_second</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">zyx_native</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">comp_slc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comps</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">single_comp_slc</span><span class="p">:</span>
                        <span class="n">_n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">slced_dat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">_t_axes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">_n</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># this is slightly fragile if they layout isn&#39;t</span>
                            <span class="c1"># strictly interlaced, but that would be rather</span>
                            <span class="c1"># pathalogical</span>
                            <span class="n">_t_axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">_n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">_n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">slced_dat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">slced_dat</span><span class="p">,</span> <span class="n">_t_axes</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">slced_dat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">slced_dat</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

                <span class="c1"># post-reshape-transform</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_reshape_transform_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cc</span><span class="p">:</span>
                        <span class="n">target_shape</span> <span class="o">=</span> <span class="n">crds</span><span class="o">.</span><span class="n">shape_cc</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">target_shape</span> <span class="o">=</span> <span class="n">crds</span><span class="o">.</span><span class="n">shape_nc</span>
                    <span class="k">if</span> <span class="n">nr_comp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">target_shape</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nr_comp</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">slced_dat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_reshape_transform_func</span><span class="p">(</span>
                        <span class="bp">self</span><span class="p">,</span> <span class="n">crds</span><span class="p">,</span> <span class="n">slced_dat</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">target_shape</span><span class="p">),</span>
                        <span class="n">comp_slc</span><span class="o">=</span><span class="n">comp_slc</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_func_kwargs</span><span class="p">)</span>

        <span class="c1"># fallback: either not hypersliceable, or the shapes didn&#39;t match up</span>
        <span class="k">if</span> <span class="n">slced_dat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">nr_comp</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nr_comp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span>
                <span class="n">slices</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nr_comp</span><span class="p">,</span> <span class="n">comp_slc</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">nr_comp</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># use xyz slices cause self.data is guarenteed to be xyz</span>
            <span class="n">slced_dat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reduced</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">slced_dat</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># if we sliced the hell out of the array, just</span>
            <span class="c1"># return the value that&#39;s left, ndarrays have the same behavior</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">slced_dat</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ctx</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">crds</span><span class="o">=</span><span class="n">crds</span><span class="p">,</span> <span class="n">zyx_native</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">fldtype</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># if we sliced a vector down to one component</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comps</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">single_comp_slc</span><span class="p">:</span>
                    <span class="c1">############</span>
                    <span class="n">comp_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp_names</span><span class="p">[</span><span class="n">comp_slc</span><span class="p">]</span>
                    <span class="n">ctx</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">comp_name</span>
                    <span class="n">ctx</span><span class="p">[</span><span class="s1">&#39;pretty_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_name</span> <span class="o">+</span>
                                          <span class="s2">&quot;$_</span><span class="si">{0}</span><span class="s2">$&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp_name</span><span class="p">))</span>
                    <span class="n">fldtype</span> <span class="o">=</span> <span class="s2">&quot;Scalar&quot;</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">slced_dat</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">fldtype</span><span class="o">=</span><span class="n">fldtype</span><span class="p">)</span>

            <span class="c1"># if there are reduced dims, put them into the deep_meta dict</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reduced</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;reduced&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduced</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">forget_source</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cached_xyz_src_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Slice the field using a string like &quot;y=3:6:2,z=0&quot; or a standard</span>
<span class="sd">        list of slice objects like one would give to numpy. In a string, i</span>
<span class="sd">        means by index, and bare numbers mean by the index closest to that</span>
<span class="sd">        value; see Coordinate.make_slice docs for an example. The semantics</span>
<span class="sd">        for keeping / droping dimensions are the same as for numpy arrays.</span>
<span class="sd">        This means selections that leave one crd in a given dimension reduce</span>
<span class="sd">        that dimension out. For other behavior see</span>
<span class="sd">        slice_reduce and slice_keep</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s2">&quot;Cell&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s2">&quot;Face&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s2">&quot;Edge&quot;</span><span class="p">)</span>
        <span class="n">sel_list</span><span class="p">,</span> <span class="n">comp_slc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_slice</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
        <span class="n">crd_slice_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">make_slice</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sel_list</span><span class="p">),</span> <span class="n">cc</span><span class="o">=</span><span class="n">cc</span><span class="p">)</span>
        <span class="n">slices</span><span class="p">,</span> <span class="n">crdlst</span><span class="p">,</span> <span class="n">reduced</span><span class="p">,</span> <span class="n">crd_type</span> <span class="o">=</span> <span class="n">crd_slice_info</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalize_slice</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span> <span class="n">crdlst</span><span class="p">,</span> <span class="n">reduced</span><span class="p">,</span> <span class="n">crd_type</span><span class="p">,</span> <span class="n">comp_slc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">slice_and_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Slice the field, then go through all dims and look for dimensions</span>
<span class="sd">        with only one coordinate. Reduce those dimensions out of the new</span>
<span class="sd">        field &quot;&quot;&quot;</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s2">&quot;Cell&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s2">&quot;Face&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s2">&quot;Edge&quot;</span><span class="p">)</span>
        <span class="n">sel_list</span><span class="p">,</span> <span class="n">comp_slc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_slice</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
        <span class="n">crd_slice_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">make_slice_reduce</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sel_list</span><span class="p">),</span> <span class="n">cc</span><span class="o">=</span><span class="n">cc</span><span class="p">)</span>
        <span class="n">slices</span><span class="p">,</span> <span class="n">crdlst</span><span class="p">,</span> <span class="n">reduced</span><span class="p">,</span> <span class="n">crd_type</span> <span class="o">=</span> <span class="n">crd_slice_info</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalize_slice</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span> <span class="n">crdlst</span><span class="p">,</span> <span class="n">reduced</span><span class="p">,</span> <span class="n">crd_type</span><span class="p">,</span> <span class="n">comp_slc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">slice_and_keep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Slice the field, then go through dimensions that would be reduced</span>
<span class="sd">        by a normal numpy slice (like saying &#39;z=0&#39;) and keep those dimensions</span>
<span class="sd">        in the new field &quot;&quot;&quot;</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s2">&quot;Cell&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s2">&quot;Face&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s2">&quot;Edge&quot;</span><span class="p">)</span>
        <span class="n">sel_list</span><span class="p">,</span> <span class="n">comp_slc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_slice</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
        <span class="n">crd_slice_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">make_slice_keep</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sel_list</span><span class="p">),</span> <span class="n">cc</span><span class="o">=</span><span class="n">cc</span><span class="p">)</span>
        <span class="n">slices</span><span class="p">,</span> <span class="n">crdlst</span><span class="p">,</span> <span class="n">reduced</span><span class="p">,</span> <span class="n">crd_type</span> <span class="o">=</span> <span class="n">crd_slice_info</span>
        <span class="c1"># print(&quot;??&quot;, type(self._src_crds), crdlst)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalize_slice</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span> <span class="n">crdlst</span><span class="p">,</span> <span class="n">reduced</span><span class="p">,</span> <span class="n">crd_type</span><span class="p">,</span> <span class="n">comp_slc</span><span class="p">)</span>

    <span class="n">slice_reduce</span> <span class="o">=</span> <span class="n">slice_and_reduce</span>
    <span class="n">slice_keep</span> <span class="o">=</span> <span class="n">slice_and_keep</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Easily slice by value (flaot), like in pandas</span>

<span class="sd">        Eample:</span>
<span class="sd">            &gt;&gt;&gt; subset1 = field[&quot;13j&quot;, &quot;14j&quot;:]</span>
<span class="sd">            &gt;&gt;&gt; subset2 = field.loc[13, 14.0:]</span>
<span class="sd">            &gt;&gt;&gt; # subset1 and subset2 should be identical</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_FldSlcProxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">do_floatify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">iloc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Easily slice by value (flaot), like in pandas</span>

<span class="sd">        Eample:</span>
<span class="sd">            &gt;&gt;&gt; subset1 = field[&quot;13j&quot;, &quot;14j&quot;:]</span>
<span class="sd">            &gt;&gt;&gt; subset2 = field.loc[13, 14.0:]</span>
<span class="sd">            &gt;&gt;&gt; # subset1 and subset2 should be identical</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_FldSlcProxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">do_floatify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">interpolated_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection</span><span class="p">):</span>
        <span class="n">seeds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crds</span><span class="o">.</span><span class="n">slice_interp</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">cc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">))</span>
        <span class="n">seed_pts</span> <span class="o">=</span> <span class="n">seeds</span><span class="o">.</span><span class="n">get_points</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
        <span class="n">fld_dat</span> <span class="o">=</span> <span class="n">interp_trilin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed_pts</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">new_fld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">fld_dat</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">crds</span><span class="o">=</span><span class="n">seeds</span><span class="p">))</span>
        <span class="n">new_fld</span> <span class="o">=</span> <span class="n">new_fld</span><span class="o">.</span><span class="n">slice_reduce</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_fld</span>

    <span class="k">def</span> <span class="nf">set_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Used for fld.__setitem__</span>

<span class="sd">        NOTE:</span>
<span class="sd">            This is only lightly tested</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s2">&quot;Cell&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s2">&quot;Face&quot;</span><span class="p">)</span> <span class="ow">or</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s2">&quot;Edge&quot;</span><span class="p">))</span>
        <span class="n">sel_list</span><span class="p">,</span> <span class="n">comp_slc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_slice</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
        <span class="n">slices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">make_slice</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sel_list</span><span class="p">),</span> <span class="n">cc</span><span class="o">=</span><span class="n">cc</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">nr_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comp</span>
            <span class="n">nr_comp</span> <span class="o">+=</span> <span class="n">slices</span><span class="p">[:</span><span class="n">nr_comp</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">)</span>
            <span class="n">slices</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nr_comp</span><span class="p">,</span> <span class="n">comp_slc</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">istype</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">type_str</span><span class="p">):</span>  <span class="c1"># noqa</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_TYPE</span> <span class="o">==</span> <span class="n">type_str</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">iscentered</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center_str</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">==</span> <span class="n">center_str</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">to_seeds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">viscid</span><span class="o">.</span><span class="n">to_seeds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nr_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nr_points</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_nr_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># pylint: disable=unused-argument</span>
        <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_nr_points</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># pylint: disable=unused-argument</span>
        <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_points</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># pylint: disable=unused-argument</span>
        <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">as_mesh</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iter_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># pylint: disable=W0613</span>
        <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">iter_points</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;clear cached data&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear_cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; iterate though all values in the data, raveled &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">val</span>

    <span class="c1">##################################</span>
    <span class="c1">## Utility methods to get at crds</span>
    <span class="c1"># these are the same as something like self._src_crds[&#39;xnc&#39;]</span>
    <span class="c1"># or self._src_crds.get_crd()</span>
    <span class="k">def</span> <span class="nf">get_crd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return crd along axis with same centering as field</span>
<span class="sd">        axis can be crd name as string, or index, as in x==2, y==1, z==2 &quot;&quot;&quot;</span>
        <span class="c1"># FIXME: work out how get_crd should act on face/edge fields since</span>
        <span class="c1">#        in this case there are 3 possibilities</span>
        <span class="n">center</span> <span class="o">=</span> <span class="s1">&#39;cell&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;face&#39;</span><span class="p">,</span> <span class="s1">&#39;edge&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_crd</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="n">shaped</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_crd_nc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns a flat ndarray of coordinates along a given axis</span>
<span class="sd">        axis can be crd name as string, or index, as in x==2, y==1, z==2 &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_nc</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="n">shaped</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_crd_cc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns a flat ndarray of coordinates along a given axis</span>
<span class="sd">        axis can be crd name as string, or index, as in x==2, y==1, z==2 &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_cc</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="n">shaped</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_crd_ec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns a flat ndarray of coordinates along a given axis</span>
<span class="sd">        axis can be crd name as string, or index, as in x==2, y==1, z==2 &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_ec</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="n">shaped</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_crd_fc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns a flat ndarray of coordinates along a given axis</span>
<span class="sd">        axis can be crd name as string, or index, as in x==2, y==1, z==2 &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_fc</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="n">shaped</span><span class="p">)</span>

    <span class="c1">## these return all crd dimensions</span>
    <span class="c1"># these are the same as something like self._src_crds.get_crds()</span>
    <span class="k">def</span> <span class="nf">get_crds_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns all face centered coords as a list of ndarrays, flat if</span>
<span class="sd">        shaped==False, or shaped if shaped==True &quot;&quot;&quot;</span>
        <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">center</span> <span class="o">==</span> <span class="s1">&#39;face&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crds_fc</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="n">shaped</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">center</span> <span class="o">==</span> <span class="s1">&#39;edge&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crds_ec</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="n">shaped</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">center</span> <span class="o">==</span> <span class="s1">&#39;cell&#39;</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_crds_cc</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="n">shaped</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">center</span> <span class="o">==</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_crds_nc</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="n">shaped</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>
            <span class="n">c</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ci</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">c</span>

    <span class="k">def</span> <span class="nf">get_crds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return all crds as list of ndarrays with same centering as field &quot;&quot;&quot;</span>
        <span class="c1"># FIXME: work out how get_crds should act on face/edge fields since</span>
        <span class="c1">#        in this case there are 3 possibilities</span>
        <span class="n">center</span> <span class="o">=</span> <span class="s1">&#39;cell&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;face&#39;</span><span class="p">,</span> <span class="s1">&#39;edge&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_crds</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="n">shaped</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_crds_nc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns all node centered coords as a list of ndarrays, flat if</span>
<span class="sd">        shaped==False, or shaped if shaped==True &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_crds_nc</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="n">shaped</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_crds_cc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns all cell centered coords as a list of ndarrays, flat if</span>
<span class="sd">        shaped==False, or shaped if shaped==True &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_crds_cc</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="n">shaped</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_crds_fc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns all face centered coords as a list of ndarrays, flat if</span>
<span class="sd">        shaped==False, or shaped if shaped==True &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_crds_fc</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="n">shaped</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_crds_ec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns all edge centered coords as a list of ndarrays, flat if</span>
<span class="sd">        shaped==False, or shaped if shaped==True &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_crds_ec</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="n">shaped</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_clist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;I&#39;m not sure anybody should use this since a clist is kind</span>
<span class="sd">        of an internal thing used for creating new coordinate instances&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_clist</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_spherical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">is_spherical</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prune</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">crds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_crds</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">prune</span><span class="p">:</span>
            <span class="n">poplist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nxi</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))):</span>
                <span class="k">if</span> <span class="n">nxi</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">poplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">crds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="n">poplist</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">crds</span><span class="p">)):</span>
                    <span class="n">slc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">crds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">slc</span><span class="p">[</span><span class="n">pi</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">crds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">crds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slc</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">crds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">meshgrid_flat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prune</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">arrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">prune</span><span class="o">=</span><span class="n">prune</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrs</span><span class="p">]</span>

    <span class="c1">######################</span>
    <span class="k">def</span> <span class="nf">shell_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">crds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a field just like this one with a new cache</span>

<span class="sd">        So, fields that belong to files are kept around for the</span>
<span class="sd">        lifetime of the file bucket, which is probably the lifetime</span>
<span class="sd">        of the main script. That means you have to explicitly clear the</span>
<span class="sd">        cache (important if reading a timeseries of fields &gt; 1GB).</span>
<span class="sd">        This function will return a new field instance with</span>
<span class="sd">        references to all the same internals as self, except for the</span>
<span class="sd">        cache. Effectively, this turns the parent field into a</span>
<span class="sd">        lightweight &quot;field shell&quot;, from which a memory intensive field</span>
<span class="sd">        can be made on the fly.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            force(bool): without force, only make a new field if the</span>
<span class="sd">                cache is not already loaded. If set to True, a field&#39;s</span>
<span class="sd">                data could be in ram twice since _cache will be filled</span>
<span class="sd">                for the new field when needed. This is probably not what</span>
<span class="sd">                you want.</span>
<span class="sd">            kwargs: additional keyword arguments to give to the Field</span>
<span class="sd">                constructor</span>

<span class="sd">        Returns:</span>
<span class="sd">            a field as described above (could be self)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">crds</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">crds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">crds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span>

        <span class="c1"># Note: this is fragile if a subclass takes additional parameters</span>
        <span class="c1"># in an overridden __init__; in that case, the developer MUST</span>
        <span class="c1"># override shell_copy and pass the extra kwargs in to here.</span>
        <span class="c1"># note, zyx_native of the child should be the same as self since we&#39;re</span>
        <span class="c1"># passing src_data here</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">crds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span>
                       <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span> <span class="n">deep_meta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">deep_meta</span><span class="p">,</span>
                       <span class="n">forget_source</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">pretty_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_name</span><span class="p">,</span>
                       <span class="n">post_reshape_transform_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">post_reshape_transform_func</span><span class="p">,</span>
                       <span class="n">transform_func_kwargs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_func_kwargs</span><span class="p">,</span>
                       <span class="n">parents</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span>

    <span class="c1">#####################</span>
    <span class="c1">## convert centering</span>
    <span class="c1"># Note: these are kind of specific to cartesian connected grids</span>

    <span class="k">def</span> <span class="nf">as_centered</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">default_width</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">center</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="n">center</span><span class="p">):</span>
            <span class="n">fld</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">center</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;cell&quot;</span><span class="p">:</span>
            <span class="n">fld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_cell_centered</span><span class="p">(</span><span class="n">default_width</span><span class="o">=</span><span class="n">default_width</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">center</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;node&quot;</span><span class="p">:</span>
            <span class="n">fld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_node_centered</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;can only give field as cell or node&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fld</span>

    <span class="k">def</span> <span class="nf">as_cell_centered</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default_width</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert field to cell centered field without discarding</span>
<span class="sd">        any data; this goes through hacky pains to make sure the data</span>
<span class="sd">        is the same as self (including the state of cachedness)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s1">&#39;node&#39;</span><span class="p">):</span>
            <span class="c1"># construct new crds</span>
            <span class="n">new_crds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">nc2cc</span><span class="p">(</span><span class="n">default_width</span><span class="o">=</span><span class="n">default_width</span><span class="p">)</span>

            <span class="c1"># this is similar to a shell copy, but it&#39;s intimately</span>
            <span class="c1"># linked to self as a parent</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_crds</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s2">&quot;cell&quot;</span><span class="p">,</span>
                           <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span>
                           <span class="n">deep_meta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">deep_meta</span><span class="p">,</span> <span class="n">forget_source</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">pretty_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_name</span><span class="p">,</span>
                           <span class="n">post_reshape_transform_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">post_reshape_transform_func</span><span class="p">,</span>
                           <span class="n">transform_func_kwargs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_func_kwargs</span><span class="p">,</span>
                           <span class="n">_parent_field</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
            <span class="c1"># FIME: this is such a hack to try our hardest to keep the</span>
            <span class="c1"># reference to the data the same</span>
            <span class="n">f</span><span class="o">.</span><span class="n">_src_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span>
            <span class="n">f</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span>

            <span class="k">return</span> <span class="n">f</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comps</span><span class="p">:</span>
            <span class="n">viscid</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Converting ECFC scalar to cell center has no &quot;</span>
                                  <span class="s2">&quot;effect on data. Only coordinates have changed. &quot;</span>
                                  <span class="s2">&quot;The result will appear staggered strangely.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap_field</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;cell&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s1">&#39;face&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">viscid</span><span class="o">.</span><span class="n">fc2cc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s1">&#39;edge&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">viscid</span><span class="o">.</span><span class="n">ec2cc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;can&#39;t yet move </span><span class="si">{0}</span><span class="s2"> to cell &quot;</span>
                                      <span class="s2">&quot;centers&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">as_node_centered</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert field to node centered field without discarding</span>
<span class="sd">        any data;  this goes through hacky pains to make sure the data</span>
<span class="sd">        is the same as self (including the state of cachedness)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s1">&#39;node&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">):</span>
            <span class="c1"># construct new crds</span>
            <span class="c1"># axes = self._src_crds.axes</span>
            <span class="c1"># crds_cc = self.get_crds_cc()</span>
            <span class="n">new_clist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_clist</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="s2">&quot;cell&quot;</span><span class="p">)</span>
            <span class="n">new_crds</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="p">)(</span><span class="n">new_clist</span><span class="p">)</span>

            <span class="c1"># this is similar to a shell copy, but it&#39;s intimately</span>
            <span class="c1"># linked to self as a parent</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_crds</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s2">&quot;node&quot;</span><span class="p">,</span>
                           <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span>
                           <span class="n">deep_meta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">deep_meta</span><span class="p">,</span> <span class="n">forget_source</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">pretty_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_name</span><span class="p">,</span>
                           <span class="n">post_reshape_transform_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">post_reshape_transform_func</span><span class="p">,</span>
                           <span class="n">transform_func_kwargs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_func_kwargs</span><span class="p">,</span>
                           <span class="n">_parent_field</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
            <span class="c1"># FIXME: this is such a hack to try our hardest to keep the</span>
            <span class="c1"># reference to the data the same</span>
            <span class="n">f</span><span class="o">.</span><span class="n">_src_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span>
            <span class="n">f</span><span class="o">.</span><span class="n">_cached_xyz_src_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_xyz_src_view</span>
            <span class="n">f</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span>

            <span class="k">return</span> <span class="n">f</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;can&#39;t yet move </span><span class="si">{0}</span><span class="s2"> to node &quot;</span>
                                      <span class="s2">&quot;centers&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">as_c_contiguous</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a Field with c-contiguous data</span>

<span class="sd">        Note:</span>
<span class="sd">            If the data is not already in memory (cached), this</span>
<span class="sd">            function will trigger a load.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Field or self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">was_loaded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_loaded</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;C_CONTIGUOUS&#39;</span><span class="p">]:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">was_loaded</span> <span class="ow">and</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clear_cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">atleast_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xl</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">xh</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return self, but with nr_sdims &gt;= 3&quot;&quot;&quot;</span>
        <span class="n">nr_sdims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_sdims</span>

        <span class="k">if</span> <span class="n">nr_sdims</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">nr_sdims</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">_cc</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s1">&#39;face&#39;</span><span class="p">)</span> <span class="ow">or</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s1">&#39;edge&#39;</span><span class="p">))</span>
            <span class="n">newcrds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crds</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">xl</span><span class="p">,</span> <span class="n">xh</span><span class="p">,</span> <span class="n">cc</span><span class="o">=</span><span class="n">_cc</span><span class="p">)</span>
            <span class="n">ctx</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;crds&#39;</span><span class="p">:</span> <span class="n">newcrds</span><span class="p">}</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_loaded</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_cc</span><span class="p">:</span>
                    <span class="n">new_shape</span> <span class="o">=</span> <span class="n">newcrds</span><span class="o">.</span><span class="n">shape_cc</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_shape</span> <span class="o">=</span> <span class="n">newcrds</span><span class="o">.</span><span class="n">shape_nc</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comps</span><span class="p">:</span>
                    <span class="n">new_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
                    <span class="n">new_shape</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_comp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comps</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">),</span> <span class="n">context</span><span class="o">=</span><span class="n">ctx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">atmost_nd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crds</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">removed_axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">remaining_axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">slc</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ni</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sshape</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ni</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">slc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">=0&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">removed_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">remaining_axes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sshape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">slc</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sshape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">slc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">slc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">=0j&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">remaining_axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">removed_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">remaining_axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">remaining_axes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">slc</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">slc</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">adjust_crds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adjustments</span><span class="p">,</span> <span class="n">name_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return shell copy with adjusted coordinates</span>

<span class="sd">        Args:</span>
<span class="sd">            adjustments (dict, number): Value to scale all coordinates</span>
<span class="sd">                by, or dict of numbers or functions to adjust specific</span>
<span class="sd">                axes separately. Functions should take a single argument,</span>
<span class="sd">                the coordinates as a :py:class:`numpy.ndarray`.</span>
<span class="sd">            name_map (dict, None): map to change crd names</span>

<span class="sd">        Returns:</span>
<span class="sd">            Field: Shell copy of self with adjusted coordinates</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; fld = viscid.zeros([16, 24])</span>
<span class="sd">            &gt;&gt;&gt; fld.adjust_crds({&#39;x&#39;: 2.0, &#39;y&#39;: lambda x: 0.5 * x})</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">adjustments</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">adj</span> <span class="o">=</span> <span class="n">adjustments</span>
            <span class="n">adjustments</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">crds</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
                <span class="n">adjustments</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">adj</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crds</span><span class="o">.</span><span class="n">axes</span>
        <span class="n">crd_arrs_nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crds_nc</span><span class="p">()</span>
        <span class="c1"># crd_arrs_cc = self.get_crds_cc()</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">arr_nc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">count</span><span class="p">(),</span> <span class="n">axes</span><span class="p">,</span> <span class="n">crd_arrs_nc</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">adjustments</span><span class="p">:</span>
                <span class="n">adj</span> <span class="o">=</span> <span class="n">adjustments</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
                    <span class="n">crd_arrs_nc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">adj</span><span class="p">(</span><span class="n">arr_nc</span><span class="p">)</span>
                    <span class="c1"># crd_arrs_cc[i] = adj(arr_cc)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">crd_arrs_nc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">adj</span> <span class="o">*</span> <span class="n">arr_nc</span>
                    <span class="c1"># crd_arrs_cc[i] = adj * arr_cc</span>

        <span class="k">if</span> <span class="n">name_map</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="ow">in</span> <span class="n">name_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">_a</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
                    <span class="n">axes</span><span class="p">[</span><span class="n">axes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">_a</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_b</span>

        <span class="n">crd_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crds</span><span class="o">.</span><span class="n">_TYPE</span>
        <span class="n">crd_type</span> <span class="o">=</span> <span class="n">crd_type</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;nonuniform&#39;</span><span class="p">,</span> <span class="s1">&#39;AUTO&#39;</span><span class="p">)</span>
        <span class="n">crd_type</span> <span class="o">=</span> <span class="n">crd_type</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="s1">&#39;AUTO&#39;</span><span class="p">)</span>
        <span class="n">new_crds</span> <span class="o">=</span> <span class="n">viscid</span><span class="o">.</span><span class="n">arrays2crds</span><span class="p">(</span><span class="n">crd_arrs_nc</span><span class="p">,</span> <span class="n">crd_type</span><span class="o">=</span><span class="n">crd_type</span><span class="p">,</span> <span class="n">crd_names</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shell_copy</span><span class="p">(</span><span class="n">crds</span><span class="o">=</span><span class="n">new_crds</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="c1">#######################</span>
    <span class="c1">## emulate a container</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; just act as if you setitem on underlying data &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_slice</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; just act as if you delitem on underlying data, probably raises a</span>
<span class="sd">        ValueError &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="c1">##########################</span>
    <span class="c1">## emulate a numeric type</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># dtype = None is ok, datatype won&#39;t change</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fldtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">npkwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; arr is the data to wrap... context is exta deep_meta to pass</span>
<span class="sd">        to the constructor. The return is just a number if arr is a</span>
<span class="sd">        1 element ndarray, this is for ufuncs that reduce to a scalar &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defer_wrapping</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;wrap&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">,</span> <span class="n">fldtype</span><span class="o">=</span><span class="n">fldtype</span><span class="p">,</span>
                              <span class="n">npkwargs</span><span class="o">=</span><span class="n">npkwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">arr</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="c1"># if just 1 number wrappen in an array, unpack the value and</span>
        <span class="c1"># return it... this is more ufuncy behavior</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">arr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">context</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">context</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">pretty_name</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;pretty_name&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pretty_name</span><span class="p">)</span>
        <span class="n">crds</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;crds&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crds</span><span class="p">)</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="c1"># should it always return the same type as self?</span>

        <span class="c1"># hack for reduction operations (ops that have npkwargs[&#39;axis&#39;])</span>
        <span class="n">defer_wrapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defer_wrapping</span>
        <span class="k">if</span> <span class="n">npkwargs</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">npkwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comps</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">axis</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comp</span><span class="p">:</span>
                    <span class="c1"># reducing vector -&gt; scalar, no need to play with crds</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">reduce_axis</span> <span class="o">=</span> <span class="n">crds</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
                    <span class="n">crd_slc</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">=0&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">reduce_axis</span><span class="p">)</span>
                    <span class="n">default_keepdims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">crds</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">iscc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscentered</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">npkwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;keepdims&quot;</span><span class="p">,</span> <span class="n">default_keepdims</span><span class="p">):</span>
                        <span class="n">crds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crds</span><span class="o">.</span><span class="n">slice_keep</span><span class="p">(</span><span class="n">crd_slc</span><span class="p">,</span> <span class="n">cc</span><span class="o">=</span><span class="n">iscc</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">crds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crds</span><span class="o">.</span><span class="n">slice_reduce</span><span class="p">(</span><span class="n">crd_slc</span><span class="p">,</span> <span class="n">cc</span><span class="o">=</span><span class="n">iscc</span><span class="p">)</span>
                    <span class="n">defer_wrapping</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># little hack for broadcasting vectors and scalars together</span>
        <span class="n">crd_shape</span> <span class="o">=</span> <span class="n">crds</span><span class="o">.</span><span class="n">shape_nc</span> <span class="k">if</span> <span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;node&quot;</span> <span class="k">else</span> <span class="n">crds</span><span class="o">.</span><span class="n">shape_cc</span>
        <span class="n">crd_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">crd_shape</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">arr_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">arr_shape</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fldtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">arr_shape</span> <span class="o">==</span> <span class="n">crd_shape</span><span class="p">:</span>
            <span class="n">fldtype</span> <span class="o">=</span> <span class="s2">&quot;scalar&quot;</span>
        <span class="k">if</span> <span class="n">fldtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">arr_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">crd_shape</span> <span class="ow">or</span>
                                <span class="n">arr_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">crd_shape</span><span class="p">):</span>
            <span class="n">fldtype</span> <span class="o">=</span> <span class="s2">&quot;vector&quot;</span>

        <span class="k">if</span> <span class="n">fldtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fldtype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fldtype</span> <span class="o">=</span> <span class="n">field_type</span><span class="p">(</span><span class="n">fldtype</span><span class="p">)</span>

        <span class="c1"># Transform functions are intentionally omitted. The idea being that</span>
        <span class="c1"># the transform was already applied when creating arr</span>
        <span class="c1"># same idea with zyx_native... whatever created arr should have done</span>
        <span class="c1"># so using the natural xyz order since that&#39;s the shape of Field.data</span>
        <span class="n">fld</span> <span class="o">=</span> <span class="n">fldtype</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">crds</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
                      <span class="n">meta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span> <span class="n">deep_meta</span><span class="o">=</span><span class="n">context</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                      <span class="n">zyx_native</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pretty_name</span><span class="o">=</span><span class="n">pretty_name</span><span class="p">)</span>
        <span class="c1"># if the operation reduced a vector to something with 1 component,</span>
        <span class="c1"># then turn the result into a ScalarField</span>
        <span class="k">if</span> <span class="n">fld</span><span class="o">.</span><span class="n">nr_comps</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">fld</span> <span class="o">=</span> <span class="n">fld</span><span class="o">.</span><span class="n">component_fields</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">fld</span>

    <span class="k">def</span> <span class="nf">wrap_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;NoName&quot;</span><span class="p">,</span> <span class="n">fldtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wrap an ndarray into a field in the local representation&quot;&quot;&quot;</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fldtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                <span class="n">fldtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fldtype</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fldtype</span> <span class="o">=</span> <span class="s2">&quot;scalar&quot;</span>
        <span class="k">return</span> <span class="n">viscid</span><span class="o">.</span><span class="n">wrap_field</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crds</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">fldtype</span><span class="o">=</span><span class="n">fldtype</span><span class="p">,</span>
                                 <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=W0613</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">out_arr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># hack because Fields don&#39;t broadcast correctly after a ufunc?</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">__array__</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">__div__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__divmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__divmod__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__lshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__lshift__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__rshift__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rdivmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__rdivmod__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>

    <span class="c1"># inplace operations are not implemented since the data</span>
    <span class="c1"># can up and disappear (due to clear_cache)... this could cause</span>
    <span class="c1"># confusion</span>
    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>
    <span class="k">def</span> <span class="nf">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>
    <span class="k">def</span> <span class="nf">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>
    <span class="k">def</span> <span class="nf">__idiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>
    <span class="k">def</span> <span class="nf">__itruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>  <span class="c1"># pylint: disable=R0201,W0613</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>
    <span class="k">def</span> <span class="nf">__ifloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>  <span class="c1"># pylint: disable=R0201,W0613</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>
    <span class="k">def</span> <span class="nf">__imod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>
    <span class="k">def</span> <span class="nf">__ipow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__neg__</span><span class="p">())</span>
    <span class="k">def</span> <span class="nf">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__pos__</span><span class="p">())</span>
    <span class="k">def</span> <span class="nf">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__abs__</span><span class="p">())</span>
    <span class="k">def</span> <span class="nf">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__invert__</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># print(&quot;::__gt__::&quot;, self.data.shape, other.shape,</span>
        <span class="c1">#       self.data.__gt__(other).shape, &quot;ndim&quot;, other.ndim)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ow</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">npkwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">npkwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">npkwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">npkwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">argpartition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kth</span><span class="o">=</span><span class="n">kth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">npkwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="nb">max</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">npkwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">conj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">npkwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">npkwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cumprod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">npkwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">npkwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">npkwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">npkwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">npkwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kth</span><span class="o">=</span><span class="n">kth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">npkwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">prod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">npkwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">ptp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">npkwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">npkwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">npkwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">npkwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">trapz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">fudge_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Integrate field over a single axis</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (str, int): axis name or index</span>
<span class="sd">            fudge_factor (callable): function that is called with</span>
<span class="sd">                func(data, crd_arr), where crd_arr is shaped. This is</span>
<span class="sd">                useful for including parts of the jacobian, like</span>
<span class="sd">                sin(theta) dtheta.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Field or float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">crds</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crds</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span>
        <span class="n">crd_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crd</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">crd_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">crd_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_comp</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comp</span> <span class="o">&gt;</span> <span class="n">axis</span><span class="p">:</span>
                <span class="n">fld_axis</span> <span class="o">=</span> <span class="n">axis</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fld_axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">fld_axis</span> <span class="o">=</span> <span class="n">axis</span>

        <span class="k">if</span> <span class="n">fudge_factor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">fudge_factor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">crd_arr</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_sdims</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sshape</span><span class="p">]</span>
            <span class="n">slc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">viscid</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slc</span><span class="p">)])</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">crd_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">fld_axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">crd_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">fld_axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">cumtrapz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">fudge_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cumulatively integrate field over a single axis</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (str, int): axis name or index</span>
<span class="sd">            fudge_factor (callable): function that is called with</span>
<span class="sd">                func(data, crd_arr), where crd_arr is shaped. This is</span>
<span class="sd">                useful for including parts of the jacobian, like</span>
<span class="sd">                sin(theta) dtheta.</span>
<span class="sd">            initial (float): Initial value</span>

<span class="sd">        Returns:</span>
<span class="sd">            Field</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="k">import</span> <span class="n">cumtrapz</span> <span class="k">as</span> <span class="n">_sp_cumtrapz</span>

            <span class="k">if</span> <span class="n">axis</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">crds</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crds</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span>
            <span class="n">crd_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crd</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">shaped</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">crd_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">crd_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_comp</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comp</span> <span class="o">&gt;</span> <span class="n">axis</span><span class="p">:</span>
                    <span class="n">fld_axis</span> <span class="o">=</span> <span class="n">axis</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fld_axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">fld_axis</span> <span class="o">=</span> <span class="n">axis</span>

            <span class="k">if</span> <span class="n">fudge_factor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">fudge_factor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">crd_arr</span><span class="p">)</span>

            <span class="n">ret</span> <span class="o">=</span> <span class="n">viscid</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">_sp_cumtrapz</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">crd_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">fld_axis</span><span class="p">,</span>
                                    <span class="n">initial</span><span class="o">=</span><span class="n">initial</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="n">viscid</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Scipy is required to perform cumtrapz&quot;</span><span class="p">)</span>
            <span class="k">raise</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># hack: np.angle casts to ndarray... that&#39;s annoying</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="n">deg</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">axes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; same behavior as numpy transpose, alse accessable</span>
<span class="sd">        using np.transpose(fld) &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="o">==</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_dims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transpose can not change number of axes&quot;</span><span class="p">)</span>
        <span class="n">clist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_clist</span><span class="p">()</span>
        <span class="n">caxes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comps</span><span class="p">:</span>
            <span class="n">caxes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_comp</span><span class="p">)</span>
            <span class="n">caxes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comp</span> <span class="k">else</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">caxes</span><span class="p">]</span>
        <span class="n">new_clist</span> <span class="o">=</span> <span class="p">[</span><span class="n">clist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">caxes</span><span class="p">]</span>
        <span class="n">cunits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_units</span><span class="p">((</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">new_clist</span><span class="p">),</span> <span class="n">allow_invalid</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">t_crds</span> <span class="o">=</span> <span class="n">coordinate</span><span class="o">.</span><span class="n">wrap_crds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">crdtype</span><span class="p">,</span> <span class="n">new_clist</span><span class="p">,</span>
                                      <span class="n">units</span><span class="o">=</span><span class="n">cunits</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">meta</span><span class="p">)</span>
        <span class="n">t_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>

        <span class="n">context</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">crds</span><span class="o">=</span><span class="n">t_crds</span><span class="p">)</span>
        <span class="c1"># i think the layout should be taken care of automagically</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">t_data</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transpose_crds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">axes</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="o">==</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_sdims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">ax_inds</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">crds</span><span class="o">.</span><span class="n">ind</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comps</span><span class="p">:</span>
            <span class="n">ax_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comp</span> <span class="k">else</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ax_inds</span><span class="p">]</span>
            <span class="n">ax_inds</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_comp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comp</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">ax_inds</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">TC</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose_crds</span><span class="p">()</span>

    <span class="n">spatial_transpose</span> <span class="o">=</span> <span class="n">transpose_crds</span>
    <span class="n">ST</span> <span class="o">=</span> <span class="n">TC</span>

    <span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_dims</span><span class="p">))</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">axes</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">axes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">swap_crd_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">crds</span><span class="o">.</span><span class="n">ind</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)]</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_sdims</span><span class="p">))</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">axes</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose_crds</span><span class="p">(</span><span class="o">*</span><span class="n">axes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">as_layout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_layout</span><span class="p">,</span> <span class="n">force_c_contiguous</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;abstract method&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_interlaced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_c_contiguous</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_layout</span><span class="p">(</span><span class="n">LAYOUT_INTERLACED</span><span class="p">,</span>
                              <span class="n">force_c_contiguous</span><span class="o">=</span><span class="n">force_c_contiguous</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_flat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_c_contiguous</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_layout</span><span class="p">(</span><span class="n">LAYOUT_FLAT</span><span class="p">,</span>
                              <span class="n">force_c_contiguous</span><span class="o">=</span><span class="n">force_c_contiguous</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">__crd_system__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_info</span><span class="p">(</span><span class="s2">&quot;crd_system&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">crd_system</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_info</span><span class="p">(</span><span class="s2">&quot;crd_system&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">crd_system</span> <span class="o">=</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">crd_system</span>


<span class="k">class</span> <span class="nc">ScalarField</span><span class="p">(</span><span class="n">Field</span><span class="p">):</span>
    <span class="n">_TYPE</span> <span class="o">=</span> <span class="s2">&quot;scalar&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nr_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_sdims</span>

    <span class="c1"># FIXME: there is probably a better way to deal with scalars not</span>
    <span class="c1"># having a component dimension</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nr_comp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Scalars have no components&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nr_comps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="c1"># no downsample / transpose / swap axes for vectors yet since that would</span>
    <span class="c1"># have the added layer of checking the layout</span>
    <span class="k">def</span> <span class="nf">downsample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; downsample the spatial dimensions by a factor of 2 &quot;&quot;&quot;</span>
        <span class="c1"># FIXME: this implementation assumes a lot about the field</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sshape</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">dat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_sdims</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">downdat</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dat</span><span class="p">[:</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">dat</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_sdims</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">downdat</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="p">(</span><span class="n">dat</span><span class="p">[:</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>
                              <span class="n">dat</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>
                              <span class="n">dat</span><span class="p">[:</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>
                              <span class="n">dat</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_sdims</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">downdat</span> <span class="o">=</span> <span class="mf">0.125</span> <span class="o">*</span> <span class="p">(</span><span class="n">dat</span><span class="p">[:</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>
                               <span class="n">dat</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>
                               <span class="n">dat</span><span class="p">[:</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>
                               <span class="n">dat</span><span class="p">[:</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>
                               <span class="n">dat</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>
                               <span class="n">dat</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>
                               <span class="n">dat</span><span class="p">[:</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>
                               <span class="n">dat</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">downclist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_clist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">cunits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">get_units</span><span class="p">((</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">downclist</span><span class="p">),</span> <span class="n">allow_invalid</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">downcrds</span> <span class="o">=</span> <span class="n">coordinate</span><span class="o">.</span><span class="n">wrap_crds</span><span class="p">(</span><span class="s2">&quot;nonuniform_cartesian&quot;</span><span class="p">,</span> <span class="n">downclist</span><span class="p">,</span>
                                        <span class="n">units</span><span class="o">=</span><span class="n">cunits</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_crds</span><span class="o">.</span><span class="n">meta</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">downdat</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;crds&quot;</span><span class="p">:</span> <span class="n">downcrds</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">as_layout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_layout</span><span class="p">,</span> <span class="n">force_c_contiguous</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">force_c_contiguous</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_c_contiguous</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>


<span class="k">class</span> <span class="nc">VectorField</span><span class="p">(</span><span class="n">Field</span><span class="p">):</span>
    <span class="n">_TYPE</span> <span class="o">=</span> <span class="s2">&quot;vector&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Keyword Arguments:</span>
<span class="sd">            comp_names (sequence): sequence of component names</span>

<span class="sd">        See Also:</span>
<span class="sd">            :py:class:`viscid.Field`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;comp_names&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">comp_names</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;comp_names&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">comp_names</span> <span class="o">=</span> <span class="n">_DEFAULT_COMPONENT_NAMES</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">VectorField</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">comp_names</span> <span class="o">=</span> <span class="n">comp_names</span>

    <span class="k">def</span> <span class="nf">component_views</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return numpy views to components individually, memory layout</span>
<span class="sd">        of the original field is maintained &quot;&quot;&quot;</span>
        <span class="n">flds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_fields</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">flds</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">component_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">layout</span> <span class="o">==</span> <span class="n">LAYOUT_FLAT</span> <span class="ow">and</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span>
            <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Field</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span><span class="p">])):</span>
            <span class="c1"># if all elements are fields</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_data</span>

        <span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_comps</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_comps</span><span class="p">):</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="n">slc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nr_comp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slc</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">lst</span>

    <span class="k">def</span> <span class="nf">as_layout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_layout</span><span class="p">,</span> <span class="n">force_c_contiguous</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an interlaced version of this field</span>

<span class="sd">        Note:</span>
<span class="sd">            This will trigger a data load if the data is not already</span>
<span class="sd">            in memory</span>

<span class="sd">        Args:</span>
<span class="sd">            to_layout: either LAYOUT_INTERLACED or LAYOUT_FLAT</span>
<span class="sd">            force_c_contiguous: if data is not c contiguous, then wrap</span>
<span class="sd">                it in another np.array() call.</span>

<span class="sd">        Returns:</span>
<span class="sd">            self, or Field if</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">was_loaded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_loaded</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">layout</span> <span class="o">==</span> <span class="n">to_layout</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">force_c_contiguous</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;C_CONTIGUOUS&#39;</span><span class="p">]:</span>
                    <span class="c1"># print(&quot;calling np.ascontiguousarray&quot;)</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># print(&quot;returning self&quot;)</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ctx</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">force_layout</span><span class="o">=</span><span class="n">to_layout</span><span class="p">)</span>
            <span class="c1"># the data load is going to wrap the array, i think it&#39;s</span>
            <span class="c1"># redundant to put an &quot;ascontiguousarray&quot; here</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">was_loaded</span> <span class="ow">and</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clear_cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_ow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># - hack because Fields don&#39;t broadcast correctly after a ufunc?</span>
        <span class="c1"># - Vector Hack if other is a scalar field to promote it to a vector</span>
        <span class="c1">#   field so numpy can broadcast interlaced vector flds w/ scalar flds</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ScalarField</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">layout</span> <span class="o">==</span> <span class="s1">&#39;interlaced&#39;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">__array__</span><span class="p">()[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">layout</span> <span class="o">==</span> <span class="s1">&#39;flat&#39;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">__array__</span><span class="p">()[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">__array__</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span>


<span class="k">class</span> <span class="nc">MatrixField</span><span class="p">(</span><span class="n">Field</span><span class="p">):</span>
    <span class="n">_TYPE</span> <span class="o">=</span> <span class="s2">&quot;matrix&quot;</span>


<span class="k">class</span> <span class="nc">TensorField</span><span class="p">(</span><span class="n">Field</span><span class="p">):</span>
    <span class="n">_TYPE</span> <span class="o">=</span> <span class="s2">&quot;tensor&quot;</span>


<span class="c1">##</span>
<span class="c1">## EOF</span>
<span class="c1">##</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2018, Kristofor Maynard.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.<br/>
    </p>
  </div>
</footer>
  </body>
</html>